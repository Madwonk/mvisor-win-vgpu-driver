From 759319d5878ea6d3fd29b393a78ec974f2a9f536 Mon Sep 17 00:00:00 2001
From: cair <rui.cai@tenclass.com>
Date: Sun, 5 Mar 2023 22:13:08 +0800
Subject: [PATCH] mesa virgl icd for windows

---
 include/drm-uapi/drm.h                        |   4 +
 include/drm-uapi/virtgpu_drm.h                |  39 +-
 include/linuz/ioccom.h                        |  91 ++
 include/linuz/xf86drm.h                       | 899 ++++++++++++++++++
 src/gallium/drivers/virgl/meson.build         |   2 +-
 src/gallium/drivers/virgl/virgl_context.c     |   9 +-
 src/gallium/drivers/virgl/virgl_resource.c    |  60 +-
 src/gallium/drivers/virgl/virgl_resource.h    |   9 +
 src/gallium/drivers/virgl/virgl_screen.c      |  46 +-
 src/gallium/drivers/virgl/virgl_video.c       |   4 +-
 src/gallium/drivers/virgl/virgl_winsys.h      |   5 +-
 src/gallium/meson.build                       |   2 +-
 src/gallium/targets/wgl/meson.build           |   2 +-
 src/gallium/targets/wgl/wgl.c                 |  37 +
 src/gallium/winsys/virgl/drm/meson.build      |   2 +-
 .../winsys/virgl/drm/virgl_drm_public.h       |   6 +-
 .../winsys/virgl/drm/virgl_drm_winsys.c       | 419 +++++++-
 .../winsys/virgl/drm/virgl_drm_winsys.h       |  12 +
 src/gallium/winsys/virgl/lib/ioctl.h          |  87 ++
 src/gallium/winsys/virgl/lib/meson.build      |  34 +
 src/gallium/winsys/virgl/lib/vgpu_api.c       | 319 +++++++
 src/gallium/winsys/virgl/lib/vgpu_api.h       |  47 +
 src/mesa/main/version.c                       |   2 +-
 23 files changed, 2090 insertions(+), 47 deletions(-)
 create mode 100644 include/linuz/ioccom.h
 create mode 100644 include/linuz/xf86drm.h
 create mode 100644 src/gallium/winsys/virgl/lib/ioctl.h
 create mode 100644 src/gallium/winsys/virgl/lib/meson.build
 create mode 100644 src/gallium/winsys/virgl/lib/vgpu_api.c
 create mode 100644 src/gallium/winsys/virgl/lib/vgpu_api.h

diff --git a/include/drm-uapi/drm.h b/include/drm-uapi/drm.h
index c76325fc3cb..7bbd41ba9e8 100644
--- a/include/drm-uapi/drm.h
+++ b/include/drm-uapi/drm.h
@@ -44,7 +44,11 @@ typedef unsigned int drm_handle_t;
 #else /* One of the BSDs */
 
 #include <stdint.h>
+#ifdef _WIN32
+#include "linuz/ioccom.h"
+#else
 #include <sys/ioccom.h>
+#endif
 #include <sys/types.h>
 typedef int8_t   __s8;
 typedef uint8_t  __u8;
diff --git a/include/drm-uapi/virtgpu_drm.h b/include/drm-uapi/virtgpu_drm.h
index 0512fde5e69..a8e2973e040 100644
--- a/include/drm-uapi/virtgpu_drm.h
+++ b/include/drm-uapi/virtgpu_drm.h
@@ -70,9 +70,15 @@ struct drm_virtgpu_execbuffer {
 	__u64 command; /* void* */
 	__u64 bo_handles;
 	__u32 num_bo_handles;
-	__s32 fence_fd; /* in/out fence fd (see VIRTGPU_EXECBUF_FENCE_FD_IN/OUT) */
 	__u32 ring_idx; /* command ring index (see VIRTGPU_EXECBUF_RING_IDX) */
+
+#ifdef _WIN32
+	HANDLE in_fence_fd;
+	HANDLE out_fence_fd;
+#else
+	__s32 fence_fd; /* in/out fence fd (see VIRTGPU_EXECBUF_FENCE_FD_IN/OUT) */
 	__u32 pad;
+#endif
 };
 
 #define VIRTGPU_PARAM_3D_FEATURES 1 /* do we have 3D features in the hw */
@@ -123,6 +129,16 @@ struct drm_virtgpu_3d_box {
 	__u32 d;
 };
 
+struct drm_virtgpu_3d_transfer {
+    __u32 bo_handle;
+    struct drm_virtgpu_3d_box box;
+    __u32 level;
+    __u32 offset;
+    __u32 stride;
+    __u32 layer_stride;
+	__u32 pad;
+};
+
 struct drm_virtgpu_3d_transfer_to_host {
 	__u32 bo_handle;
 	struct drm_virtgpu_3d_box box;
@@ -130,6 +146,7 @@ struct drm_virtgpu_3d_transfer_to_host {
 	__u32 offset;
 	__u32 stride;
 	__u32 layer_stride;
+	__u32 pad;
 };
 
 struct drm_virtgpu_3d_transfer_from_host {
@@ -139,6 +156,7 @@ struct drm_virtgpu_3d_transfer_from_host {
 	__u32 offset;
 	__u32 stride;
 	__u32 layer_stride;
+	__u32 pad;
 };
 
 #define VIRTGPU_WAIT_NOWAIT 1 /* like it */
@@ -169,15 +187,24 @@ struct drm_virtgpu_resource_create_blob {
 	__u32 bo_handle;
 	__u32 res_handle;
 	__u64 size;
+	__u64 blob_id;
 
-	/*
-	 * for 3D contexts with VIRTGPU_BLOB_MEM_HOST3D_GUEST and
-	 * VIRTGPU_BLOB_MEM_HOST3D otherwise, must be zero.
-	 */
+#ifdef _WIN32
+	__u32 format;
+	__u32 bind;
+	__u32 target;
+	__u32 width;
+	__u32 height;
+	__u32 depth;
+	__u32 array_size;
+	__u32 last_level;
+	__u32 nr_samples;
+	__u32 flags;
+#else
 	__u32 pad;
 	__u32 cmd_size;
 	__u64 cmd;
-	__u64 blob_id;
+#endif
 };
 
 #define VIRTGPU_CONTEXT_PARAM_CAPSET_ID       0x0001
diff --git a/include/linuz/ioccom.h b/include/linuz/ioccom.h
new file mode 100644
index 00000000000..00e87d9aa3a
--- /dev/null
+++ b/include/linuz/ioccom.h
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
+ *
+ * @APPLE_LICENSE_HEADER_START@
+ * 
+ * The contents of this file constitute Original Code as defined in and
+ * are subject to the Apple Public Source License Version 1.1 (the
+ * "License").  You may not use this file except in compliance with the
+ * License.  Please obtain a copy of the License at
+ * http://www.apple.com/publicsource and read it before using this file.
+ * 
+ * This Original Code and all software distributed under the License are
+ * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
+ * License for the specific language governing rights and limitations
+ * under the License.
+ * 
+ * @APPLE_LICENSE_HEADER_END@
+ */
+/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
+/*-
+ * Copyright (c) 1982, 1986, 1990, 1993, 1994
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)ioccom.h	8.2 (Berkeley) 3/28/94
+ */
+
+#ifndef	_SYS_IOCCOM_H_
+#define	_SYS_IOCCOM_H_
+
+/*
+ * Ioctl's have the command encoded in the lower word, and the size of
+ * any in or out parameters in the upper word.  The high 3 bits of the
+ * upper word are used to encode the in/out status of the parameter.
+ */
+#define	IOCPARM_MASK	0x1fff		/* parameter length, at most 13 bits */
+#define	IOCPARM_LEN(x)	(((x) >> 16) & IOCPARM_MASK)
+#define	IOCBASECMD(x)	((x) & ~(IOCPARM_MASK << 16))
+#define	IOCGROUP(x)	(((x) >> 8) & 0xff)
+
+#define	IOCPARM_MAX	(IOCPARM_MASK + 1)	/* max size of ioctl args */
+				/* no parameters */
+#define	IOC_VOID	(unsigned long)0x20000000
+				/* copy parameters out */
+#define	IOC_OUT		(unsigned long)0x40000000
+				/* copy parameters in */
+#define	IOC_IN		(unsigned long)0x80000000
+				/* copy paramters in and out */
+#define	IOC_INOUT	(IOC_IN|IOC_OUT)
+				/* mask for IN/OUT/VOID */
+#define	IOC_DIRMASK	(unsigned long)0xe0000000
+
+#define	_IOC(inout,group,num,len) \
+	(inout | ((len & IOCPARM_MASK) << 16) | ((group) << 8) | (num))
+#define	_IO(g,n)	_IOC(IOC_VOID,	(g), (n), 0)
+#define	_IOR(g,n,t)	_IOC(IOC_OUT,	(g), (n), sizeof(t))
+#define	_IOW(g,n,t)	_IOC(IOC_IN,	(g), (n), sizeof(t))
+/* this should be _IORW, but stdio got there first */
+#define	_IOWR(g,n,t)	_IOC(IOC_INOUT,	(g), (n), sizeof(t))
+
+#endif /* !_SYS_IOCCOM_H_ */
diff --git a/include/linuz/xf86drm.h b/include/linuz/xf86drm.h
new file mode 100644
index 00000000000..be8a0bad908
--- /dev/null
+++ b/include/linuz/xf86drm.h
@@ -0,0 +1,899 @@
+/**
+ * \file xf86drm.h 
+ * OS-independent header for DRM user-level library interface.
+ *
+ * \author Rickard E. (Rik) Faith <faith@valinux.com>
+ */
+ 
+/*
+ * Copyright 1999, 2000 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _XF86DRM_H_
+#define _XF86DRM_H_
+
+#include <stdarg.h>
+#include <sys/types.h>
+#include <stdint.h>
+#include <drm.h>
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+#ifndef DRM_MAX_MINOR
+#define DRM_MAX_MINOR   16
+#endif
+
+#if defined(__linux__)
+
+#define DRM_IOCTL_NR(n)		_IOC_NR(n)
+#define DRM_IOC_VOID		_IOC_NONE
+#define DRM_IOC_READ		_IOC_READ
+#define DRM_IOC_WRITE		_IOC_WRITE
+#define DRM_IOC_READWRITE	_IOC_READ|_IOC_WRITE
+#define DRM_IOC(dir, group, nr, size) _IOC(dir, group, nr, size)
+
+#else /* One of the *BSDs */
+
+#if (defined(__QNX__) || defined(__QNXNTO__)) /* NVIDIA - It's 'sys/ioctl.h' on QNX7 */
+#include <sys/ioctl.h>
+#else
+#include <sys/ioccom.h>
+#endif
+#define DRM_IOCTL_NR(n)         ((n) & 0xff)
+#define DRM_IOC_VOID            IOC_VOID
+#define DRM_IOC_READ            IOC_OUT
+#define DRM_IOC_WRITE           IOC_IN
+#define DRM_IOC_READWRITE       IOC_INOUT
+#define DRM_IOC(dir, group, nr, size) _IOC(dir, group, nr, size)
+
+#endif
+
+				/* Defaults, if nothing set in xf86config */
+#define DRM_DEV_UID	 0
+#define DRM_DEV_GID	 0
+/* Default /dev/dri directory permissions 0755 */
+#define DRM_DEV_DIRMODE	 	\
+	(S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH)
+#define DRM_DEV_MODE	 (S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP)
+
+#ifdef __OpenBSD__
+#define DRM_DIR_NAME  "/dev"
+#define DRM_DEV_NAME  "%s/drm%d"
+#define DRM_CONTROL_DEV_NAME  "%s/drmC%d"
+#define DRM_RENDER_DEV_NAME  "%s/drmR%d"
+#else
+#define DRM_DIR_NAME  "/dev/dri"
+#define DRM_DEV_NAME  "%s/card%d"
+#define DRM_CONTROL_DEV_NAME  "%s/controlD%d"
+#define DRM_RENDER_DEV_NAME  "%s/renderD%d"
+#define DRM_PROC_NAME "/proc/dri/" /* For backward Linux compatibility */
+#endif
+
+#define DRM_ERR_NO_DEVICE  (-1001)
+#define DRM_ERR_NO_ACCESS  (-1002)
+#define DRM_ERR_NOT_ROOT   (-1003)
+#define DRM_ERR_INVALID    (-1004)
+#define DRM_ERR_NO_FD      (-1005)
+
+#define DRM_AGP_NO_HANDLE 0
+
+typedef unsigned int  drmSize,     *drmSizePtr;	    /**< For mapped regions */
+typedef void          *drmAddress, **drmAddressPtr; /**< For mapped regions */
+
+#if (__GNUC__ >= 3)
+#define DRM_PRINTFLIKE(f, a) __attribute__ ((format(__printf__, f, a)))
+#else
+#define DRM_PRINTFLIKE(f, a)
+#endif
+
+typedef struct _drmServerInfo {
+  int (*debug_print)(const char *format, va_list ap) DRM_PRINTFLIKE(1,0);
+  int (*load_module)(const char *name);
+  void (*get_perms)(gid_t *, mode_t *);
+} drmServerInfo, *drmServerInfoPtr;
+
+typedef struct drmHashEntry {
+    int      fd;
+    void     (*f)(int, void *, void *);
+    void     *tagTable;
+} drmHashEntry;
+
+extern int drmIoctl(int fd, unsigned long request, void *arg);
+extern void *drmGetHashTable(void);
+extern drmHashEntry *drmGetEntry(int fd);
+
+/**
+ * Driver version information.
+ *
+ * \sa drmGetVersion() and drmSetVersion().
+ */
+typedef struct _drmVersion {
+    int     version_major;        /**< Major version */
+    int     version_minor;        /**< Minor version */
+    int     version_patchlevel;   /**< Patch level */
+    int     name_len; 	          /**< Length of name buffer */
+    char    *name;	          /**< Name of driver */
+    int     date_len;             /**< Length of date buffer */
+    char    *date;                /**< User-space buffer to hold date */
+    int     desc_len;	          /**< Length of desc buffer */
+    char    *desc;                /**< User-space buffer to hold desc */
+} drmVersion, *drmVersionPtr;
+
+typedef struct _drmStats {
+    unsigned long count;	     /**< Number of data */
+    struct {
+	unsigned long value;	     /**< Value from kernel */
+	const char    *long_format;  /**< Suggested format for long_name */
+	const char    *long_name;    /**< Long name for value */
+	const char    *rate_format;  /**< Suggested format for rate_name */
+	const char    *rate_name;    /**< Short name for value per second */
+	int           isvalue;       /**< True if value (vs. counter) */
+	const char    *mult_names;   /**< Multiplier names (e.g., "KGM") */
+	int           mult;          /**< Multiplier value (e.g., 1024) */
+	int           verbose;       /**< Suggest only in verbose output */
+    } data[15];
+} drmStatsT;
+
+
+				/* All of these enums *MUST* match with the
+                                   kernel implementation -- so do *NOT*
+                                   change them!  (The drmlib implementation
+                                   will just copy the flags instead of
+                                   translating them.) */
+typedef enum {
+    DRM_FRAME_BUFFER    = 0,      /**< WC, no caching, no core dump */
+    DRM_REGISTERS       = 1,      /**< no caching, no core dump */
+    DRM_SHM             = 2,      /**< shared, cached */
+    DRM_AGP             = 3,	  /**< AGP/GART */
+    DRM_SCATTER_GATHER  = 4,	  /**< PCI scatter/gather */
+    DRM_CONSISTENT      = 5	  /**< PCI consistent */
+} drmMapType;
+
+typedef enum {
+    DRM_RESTRICTED      = 0x0001, /**< Cannot be mapped to client-virtual */
+    DRM_READ_ONLY       = 0x0002, /**< Read-only in client-virtual */
+    DRM_LOCKED          = 0x0004, /**< Physical pages locked */
+    DRM_KERNEL          = 0x0008, /**< Kernel requires access */
+    DRM_WRITE_COMBINING = 0x0010, /**< Use write-combining, if available */
+    DRM_CONTAINS_LOCK   = 0x0020, /**< SHM page that contains lock */
+    DRM_REMOVABLE	= 0x0040  /**< Removable mapping */
+} drmMapFlags;
+
+/**
+ * \warning These values *MUST* match drm.h
+ */
+typedef enum {
+    /** \name Flags for DMA buffer dispatch */
+    /*@{*/
+    DRM_DMA_BLOCK        = 0x01, /**< 
+				  * Block until buffer dispatched.
+				  * 
+				  * \note the buffer may not yet have been
+				  * processed by the hardware -- getting a
+				  * hardware lock with the hardware quiescent
+				  * will ensure that the buffer has been
+				  * processed.
+				  */
+    DRM_DMA_WHILE_LOCKED = 0x02, /**< Dispatch while lock held */
+    DRM_DMA_PRIORITY     = 0x04, /**< High priority dispatch */
+    /*@}*/
+
+    /** \name Flags for DMA buffer request */
+    /*@{*/
+    DRM_DMA_WAIT         = 0x10, /**< Wait for free buffers */
+    DRM_DMA_SMALLER_OK   = 0x20, /**< Smaller-than-requested buffers OK */
+    DRM_DMA_LARGER_OK    = 0x40  /**< Larger-than-requested buffers OK */
+    /*@}*/
+} drmDMAFlags;
+
+typedef enum {
+    DRM_PAGE_ALIGN       = 0x01,
+    DRM_AGP_BUFFER       = 0x02,
+    DRM_SG_BUFFER        = 0x04,
+    DRM_FB_BUFFER        = 0x08,
+    DRM_PCI_BUFFER_RO    = 0x10
+} drmBufDescFlags;
+
+typedef enum {
+    DRM_LOCK_READY      = 0x01, /**< Wait until hardware is ready for DMA */
+    DRM_LOCK_QUIESCENT  = 0x02, /**< Wait until hardware quiescent */
+    DRM_LOCK_FLUSH      = 0x04, /**< Flush this context's DMA queue first */
+    DRM_LOCK_FLUSH_ALL  = 0x08, /**< Flush all DMA queues first */
+				/* These *HALT* flags aren't supported yet
+                                   -- they will be used to support the
+                                   full-screen DGA-like mode. */
+    DRM_HALT_ALL_QUEUES = 0x10, /**< Halt all current and future queues */
+    DRM_HALT_CUR_QUEUES = 0x20  /**< Halt all current queues */
+} drmLockFlags;
+
+typedef enum {
+    DRM_CONTEXT_PRESERVED = 0x01, /**< This context is preserved and
+				     never swapped. */
+    DRM_CONTEXT_2DONLY    = 0x02  /**< This context is for 2D rendering only. */
+} drm_context_tFlags, *drm_context_tFlagsPtr;
+
+typedef struct _drmBufDesc {
+    int              count;	  /**< Number of buffers of this size */
+    int              size;	  /**< Size in bytes */
+    int              low_mark;	  /**< Low water mark */
+    int              high_mark;	  /**< High water mark */
+} drmBufDesc, *drmBufDescPtr;
+
+typedef struct _drmBufInfo {
+    int              count;	  /**< Number of buffers described in list */
+    drmBufDescPtr    list;	  /**< List of buffer descriptions */
+} drmBufInfo, *drmBufInfoPtr;
+
+typedef struct _drmBuf {
+    int              idx;	  /**< Index into the master buffer list */
+    int              total;	  /**< Buffer size */
+    int              used;	  /**< Amount of buffer in use (for DMA) */
+    drmAddress       address;	  /**< Address */
+} drmBuf, *drmBufPtr;
+
+/**
+ * Buffer mapping information.
+ *
+ * Used by drmMapBufs() and drmUnmapBufs() to store information about the
+ * mapped buffers.
+ */
+typedef struct _drmBufMap {
+    int              count;	  /**< Number of buffers mapped */
+    drmBufPtr        list;	  /**< Buffers */
+} drmBufMap, *drmBufMapPtr;
+
+typedef struct _drmLock {
+    volatile unsigned int lock;
+    char                      padding[60];
+    /* This is big enough for most current (and future?) architectures:
+       DEC Alpha:              32 bytes
+       Intel Merced:           ?
+       Intel P5/PPro/PII/PIII: 32 bytes
+       Intel StrongARM:        32 bytes
+       Intel i386/i486:        16 bytes
+       MIPS:                   32 bytes (?)
+       Motorola 68k:           16 bytes
+       Motorola PowerPC:       32 bytes
+       Sun SPARC:              32 bytes
+    */
+} drmLock, *drmLockPtr;
+
+/**
+ * Indices here refer to the offset into
+ * list in drmBufInfo
+ */
+typedef struct _drmDMAReq {
+    drm_context_t    context;  	  /**< Context handle */
+    int           send_count;     /**< Number of buffers to send */
+    int           *send_list;     /**< List of handles to buffers */
+    int           *send_sizes;    /**< Lengths of data to send, in bytes */
+    drmDMAFlags   flags;          /**< Flags */
+    int           request_count;  /**< Number of buffers requested */
+    int           request_size;	  /**< Desired size of buffers requested */
+    int           *request_list;  /**< Buffer information */
+    int           *request_sizes; /**< Minimum acceptable sizes */
+    int           granted_count;  /**< Number of buffers granted at this size */
+} drmDMAReq, *drmDMAReqPtr;
+
+typedef struct _drmRegion {
+    drm_handle_t     handle;
+    unsigned int  offset;
+    drmSize       size;
+    drmAddress    map;
+} drmRegion, *drmRegionPtr;
+
+typedef struct _drmTextureRegion {
+    unsigned char next;
+    unsigned char prev;
+    unsigned char in_use;
+    unsigned char padding;	/**< Explicitly pad this out */
+    unsigned int  age;
+} drmTextureRegion, *drmTextureRegionPtr;
+
+
+typedef enum {
+    DRM_VBLANK_ABSOLUTE = 0x0,	/**< Wait for specific vblank sequence number */
+    DRM_VBLANK_RELATIVE = 0x1,	/**< Wait for given number of vblanks */
+    /* bits 1-6 are reserved for high crtcs */
+    DRM_VBLANK_HIGH_CRTC_MASK = 0x0000003e,
+    DRM_VBLANK_EVENT = 0x4000000,	/**< Send event instead of blocking */
+    DRM_VBLANK_FLIP = 0x8000000,	/**< Scheduled buffer swap should flip */
+    DRM_VBLANK_NEXTONMISS = 0x10000000,	/**< If missed, wait for next vblank */
+    DRM_VBLANK_SECONDARY = 0x20000000,	/**< Secondary display controller */
+    DRM_VBLANK_SIGNAL   = 0x40000000	/* Send signal instead of blocking */
+} drmVBlankSeqType;
+#define DRM_VBLANK_HIGH_CRTC_SHIFT 1
+
+typedef struct _drmVBlankReq {
+	drmVBlankSeqType type;
+	unsigned int sequence;
+	unsigned long signal;
+} drmVBlankReq, *drmVBlankReqPtr;
+
+typedef struct _drmVBlankReply {
+	drmVBlankSeqType type;
+	unsigned int sequence;
+	long tval_sec;
+	long tval_usec;
+} drmVBlankReply, *drmVBlankReplyPtr;
+
+typedef union _drmVBlank {
+	drmVBlankReq request;
+	drmVBlankReply reply;
+} drmVBlank, *drmVBlankPtr;
+
+typedef struct _drmSetVersion {
+	int drm_di_major;
+	int drm_di_minor;
+	int drm_dd_major;
+	int drm_dd_minor;
+} drmSetVersion, *drmSetVersionPtr;
+
+#define __drm_dummy_lock(lock) (*(__volatile__ unsigned int *)lock)
+
+#define DRM_LOCK_HELD  0x80000000U /**< Hardware lock is held */
+#define DRM_LOCK_CONT  0x40000000U /**< Hardware lock is contended */
+
+#if defined(__GNUC__) && (__GNUC__ >= 2)
+# if defined(__i386) || defined(__AMD64__) || defined(__x86_64__) || defined(__amd64__)
+				/* Reflect changes here to drmP.h */
+#define DRM_CAS(lock,old,new,__ret)                                    \
+	do {                                                           \
+                int __dummy;	/* Can't mark eax as clobbered */      \
+		__asm__ __volatile__(                                  \
+			"lock ; cmpxchg %4,%1\n\t"                     \
+                        "setnz %0"                                     \
+			: "=d" (__ret),                                \
+   			  "=m" (__drm_dummy_lock(lock)),               \
+                          "=a" (__dummy)                               \
+			: "2" (old),                                   \
+			  "r" (new));                                  \
+	} while (0)
+
+#elif defined(__alpha__)
+
+#define	DRM_CAS(lock, old, new, ret)		\
+	do {					\
+		int tmp, old32;			\
+		__asm__ __volatile__(		\
+		"	addl	$31, %5, %3\n"	\
+		"1:	ldl_l	%0, %2\n"	\
+		"	cmpeq	%0, %3, %1\n"	\
+		"	beq	%1, 2f\n"	\
+		"	mov	%4, %0\n"	\
+		"	stl_c	%0, %2\n"	\
+		"	beq	%0, 3f\n"	\
+		"	mb\n"			\
+		"2:	cmpeq	%1, 0, %1\n"	\
+		".subsection 2\n"		\
+		"3:	br	1b\n"		\
+		".previous"			\
+		: "=&r"(tmp), "=&r"(ret),	\
+		  "=m"(__drm_dummy_lock(lock)),	\
+		  "=&r"(old32)			\
+		: "r"(new), "r"(old)		\
+		: "memory");			\
+	} while (0)
+
+#elif defined(__sparc__)
+
+#define DRM_CAS(lock,old,new,__ret)				\
+do {	register unsigned int __old __asm("o0");		\
+	register unsigned int __new __asm("o1");		\
+	register volatile unsigned int *__lock __asm("o2");	\
+	__old = old;						\
+	__new = new;						\
+	__lock = (volatile unsigned int *)lock;			\
+	__asm__ __volatile__(					\
+		/*"cas [%2], %3, %0"*/				\
+		".word 0xd3e29008\n\t"				\
+		/*"membar #StoreStore | #StoreLoad"*/		\
+		".word 0x8143e00a"				\
+		: "=&r" (__new)					\
+		: "0" (__new),					\
+		  "r" (__lock),					\
+		  "r" (__old)					\
+		: "memory");					\
+	__ret = (__new != __old);				\
+} while(0)
+
+#elif defined(__ia64__)
+
+#ifdef __INTEL_COMPILER
+/* this currently generates bad code (missing stop bits)... */
+#include <ia64intrin.h>
+
+#define DRM_CAS(lock,old,new,__ret)					      \
+	do {								      \
+		unsigned long __result, __old = (old) & 0xffffffff;		\
+		__mf();							      	\
+		__result = _InterlockedCompareExchange_acq(&__drm_dummy_lock(lock), (new), __old);\
+		__ret = (__result) != (__old);					\
+/*		__ret = (__sync_val_compare_and_swap(&__drm_dummy_lock(lock), \
+						     (old), (new))	      \
+			 != (old));					      */\
+	} while (0)
+
+#else
+#define DRM_CAS(lock,old,new,__ret)					  \
+	do {								  \
+		unsigned int __result, __old = (old);			  \
+		__asm__ __volatile__(					  \
+			"mf\n"						  \
+			"mov ar.ccv=%2\n"				  \
+			";;\n"						  \
+			"cmpxchg4.acq %0=%1,%3,ar.ccv"			  \
+			: "=r" (__result), "=m" (__drm_dummy_lock(lock))  \
+			: "r" ((unsigned long)__old), "r" (new)			  \
+			: "memory");					  \
+		__ret = (__result) != (__old);				  \
+	} while (0)
+
+#endif
+
+#elif defined(__powerpc__)
+
+#define DRM_CAS(lock,old,new,__ret)			\
+	do {						\
+		__asm__ __volatile__(			\
+			"sync;"				\
+			"0:    lwarx %0,0,%1;"		\
+			"      xor. %0,%3,%0;"		\
+			"      bne 1f;"			\
+			"      stwcx. %2,0,%1;"		\
+			"      bne- 0b;"		\
+			"1:    "			\
+			"sync;"				\
+		: "=&r"(__ret)				\
+		: "r"(lock), "r"(new), "r"(old)		\
+		: "cr0", "memory");			\
+	} while (0)
+
+#endif /* architecture */
+#endif /* __GNUC__ >= 2 */
+
+#ifndef DRM_CAS
+#define DRM_CAS(lock,old,new,ret) do { ret=1; } while (0) /* FAST LOCK FAILS */
+#endif
+
+#if defined(__alpha__)
+#define DRM_CAS_RESULT(_result)		long _result
+#elif defined(__powerpc__)
+#define DRM_CAS_RESULT(_result)		int _result
+#else
+#define DRM_CAS_RESULT(_result)		char _result
+#endif
+
+#define DRM_LIGHT_LOCK(fd,lock,context)                                \
+	do {                                                           \
+                DRM_CAS_RESULT(__ret);                                 \
+		DRM_CAS(lock,context,DRM_LOCK_HELD|context,__ret);     \
+                if (__ret) drmGetLock(fd,context,0);                   \
+        } while(0)
+
+				/* This one counts fast locks -- for
+                                   benchmarking only. */
+#define DRM_LIGHT_LOCK_COUNT(fd,lock,context,count)                    \
+	do {                                                           \
+                DRM_CAS_RESULT(__ret);                                 \
+		DRM_CAS(lock,context,DRM_LOCK_HELD|context,__ret);     \
+                if (__ret) drmGetLock(fd,context,0);                   \
+                else       ++count;                                    \
+        } while(0)
+
+#define DRM_LOCK(fd,lock,context,flags)                                \
+	do {                                                           \
+		if (flags) drmGetLock(fd,context,flags);               \
+		else       DRM_LIGHT_LOCK(fd,lock,context);            \
+	} while(0)
+
+#define DRM_UNLOCK(fd,lock,context)                                    \
+	do {                                                           \
+                DRM_CAS_RESULT(__ret);                                 \
+		DRM_CAS(lock,DRM_LOCK_HELD|context,context,__ret);     \
+                if (__ret) drmUnlock(fd,context);                      \
+        } while(0)
+
+				/* Simple spin locks */
+#define DRM_SPINLOCK(spin,val)                                         \
+	do {                                                           \
+            DRM_CAS_RESULT(__ret);                                     \
+	    do {                                                       \
+		DRM_CAS(spin,0,val,__ret);                             \
+		if (__ret) while ((spin)->lock);                       \
+	    } while (__ret);                                           \
+	} while(0)
+
+#define DRM_SPINLOCK_TAKE(spin,val)                                    \
+	do {                                                           \
+            DRM_CAS_RESULT(__ret);                                     \
+            int  cur;                                                  \
+	    do {                                                       \
+                cur = (*spin).lock;                                    \
+		DRM_CAS(spin,cur,val,__ret);                           \
+	    } while (__ret);                                           \
+	} while(0)
+
+#define DRM_SPINLOCK_COUNT(spin,val,count,__ret)                       \
+	do {                                                           \
+            int  __i;                                                  \
+            __ret = 1;                                                 \
+            for (__i = 0; __ret && __i < count; __i++) {               \
+		DRM_CAS(spin,0,val,__ret);                             \
+		if (__ret) for (;__i < count && (spin)->lock; __i++);  \
+	    }                                                          \
+	} while(0)
+
+#define DRM_SPINUNLOCK(spin,val)                                       \
+	do {                                                           \
+            DRM_CAS_RESULT(__ret);                                     \
+            if ((*spin).lock == val) { /* else server stole lock */    \
+	        do {                                                   \
+		    DRM_CAS(spin,val,0,__ret);                         \
+	        } while (__ret);                                       \
+            }                                                          \
+	} while(0)
+
+
+
+/* General user-level programmer's API: unprivileged */
+extern int           drmAvailable(void);
+extern int           drmOpen(const char *name, const char *busid);
+
+#define DRM_NODE_PRIMARY 0
+#define DRM_NODE_CONTROL 1
+#define DRM_NODE_RENDER  2
+#define DRM_NODE_MAX     3
+
+extern int           drmOpenWithType(const char *name, const char *busid,
+                                     int type);
+
+extern int           drmOpenControl(int minor);
+extern int           drmOpenRender(int minor);
+extern int           drmClose(int fd);
+extern drmVersionPtr drmGetVersion(int fd);
+extern drmVersionPtr drmGetLibVersion(int fd);
+extern int           drmGetCap(int fd, uint64_t capability, uint64_t *value);
+extern void          drmFreeVersion(drmVersionPtr);
+extern int           drmGetMagic(int fd, drm_magic_t * magic);
+extern char          *drmGetBusid(int fd);
+extern int           drmGetInterruptFromBusID(int fd, int busnum, int devnum,
+					      int funcnum);
+extern int           drmGetMap(int fd, int idx, drm_handle_t *offset,
+			       drmSize *size, drmMapType *type,
+			       drmMapFlags *flags, drm_handle_t *handle,
+			       int *mtrr);
+extern int           drmGetClient(int fd, int idx, int *auth, int *pid,
+				  int *uid, unsigned long *magic,
+				  unsigned long *iocs);
+extern int           drmGetStats(int fd, drmStatsT *stats);
+extern int           drmSetInterfaceVersion(int fd, drmSetVersion *version);
+extern int           drmCommandNone(int fd, unsigned long drmCommandIndex);
+extern int           drmCommandRead(int fd, unsigned long drmCommandIndex,
+                                    void *data, unsigned long size);
+extern int           drmCommandWrite(int fd, unsigned long drmCommandIndex,
+                                     void *data, unsigned long size);
+extern int           drmCommandWriteRead(int fd, unsigned long drmCommandIndex,
+                                         void *data, unsigned long size);
+
+/* General user-level programmer's API: X server (root) only  */
+extern void          drmFreeBusid(const char *busid);
+extern int           drmSetBusid(int fd, const char *busid);
+extern int           drmAuthMagic(int fd, drm_magic_t magic);
+extern int           drmAddMap(int fd,
+			       drm_handle_t offset,
+			       drmSize size,
+			       drmMapType type,
+			       drmMapFlags flags,
+			       drm_handle_t * handle);
+extern int	     drmRmMap(int fd, drm_handle_t handle);
+extern int	     drmAddContextPrivateMapping(int fd, drm_context_t ctx_id,
+						 drm_handle_t handle);
+
+extern int           drmAddBufs(int fd, int count, int size,
+				drmBufDescFlags flags,
+				int agp_offset);
+extern int           drmMarkBufs(int fd, double low, double high);
+extern int           drmCreateContext(int fd, drm_context_t * handle);
+extern int           drmSetContextFlags(int fd, drm_context_t context,
+					drm_context_tFlags flags);
+extern int           drmGetContextFlags(int fd, drm_context_t context,
+					drm_context_tFlagsPtr flags);
+extern int           drmAddContextTag(int fd, drm_context_t context, void *tag);
+extern int           drmDelContextTag(int fd, drm_context_t context);
+extern void          *drmGetContextTag(int fd, drm_context_t context);
+extern drm_context_t * drmGetReservedContextList(int fd, int *count);
+extern void          drmFreeReservedContextList(drm_context_t *);
+extern int           drmSwitchToContext(int fd, drm_context_t context);
+extern int           drmDestroyContext(int fd, drm_context_t handle);
+extern int           drmCreateDrawable(int fd, drm_drawable_t * handle);
+extern int           drmDestroyDrawable(int fd, drm_drawable_t handle);
+extern int           drmUpdateDrawableInfo(int fd, drm_drawable_t handle,
+					   drm_drawable_info_type_t type,
+					   unsigned int num, void *data);
+extern int           drmCtlInstHandler(int fd, int irq);
+extern int           drmCtlUninstHandler(int fd);
+extern int           drmSetClientCap(int fd, uint64_t capability,
+				     uint64_t value);
+
+extern int           drmCrtcGetSequence(int fd, uint32_t crtcId,
+					uint64_t *sequence, uint64_t *ns);
+extern int           drmCrtcQueueSequence(int fd, uint32_t crtcId,
+					  uint32_t flags, uint64_t sequence,
+					  uint64_t *sequence_queued,
+					  uint64_t user_data);
+/* General user-level programmer's API: authenticated client and/or X */
+extern int           drmMap(int fd,
+			    drm_handle_t handle,
+			    drmSize size,
+			    drmAddressPtr address);
+extern int           drmUnmap(drmAddress address, drmSize size);
+extern drmBufInfoPtr drmGetBufInfo(int fd);
+extern drmBufMapPtr  drmMapBufs(int fd);
+extern int           drmUnmapBufs(drmBufMapPtr bufs);
+extern int           drmDMA(int fd, drmDMAReqPtr request);
+extern int           drmFreeBufs(int fd, int count, int *list);
+extern int           drmGetLock(int fd,
+			        drm_context_t context,
+			        drmLockFlags flags);
+extern int           drmUnlock(int fd, drm_context_t context);
+extern int           drmFinish(int fd, int context, drmLockFlags flags);
+extern int	     drmGetContextPrivateMapping(int fd, drm_context_t ctx_id, 
+						 drm_handle_t * handle);
+
+/* AGP/GART support: X server (root) only */
+extern int           drmAgpAcquire(int fd);
+extern int           drmAgpRelease(int fd);
+extern int           drmAgpEnable(int fd, unsigned long mode);
+extern int           drmAgpAlloc(int fd, unsigned long size,
+				 unsigned long type, unsigned long *address,
+				 drm_handle_t *handle);
+extern int           drmAgpFree(int fd, drm_handle_t handle);
+extern int 	     drmAgpBind(int fd, drm_handle_t handle,
+				unsigned long offset);
+extern int           drmAgpUnbind(int fd, drm_handle_t handle);
+
+/* AGP/GART info: authenticated client and/or X */
+extern int           drmAgpVersionMajor(int fd);
+extern int           drmAgpVersionMinor(int fd);
+extern unsigned long drmAgpGetMode(int fd);
+extern unsigned long drmAgpBase(int fd); /* Physical location */
+extern unsigned long drmAgpSize(int fd); /* Bytes */
+extern unsigned long drmAgpMemoryUsed(int fd);
+extern unsigned long drmAgpMemoryAvail(int fd);
+extern unsigned int  drmAgpVendorId(int fd);
+extern unsigned int  drmAgpDeviceId(int fd);
+
+/* PCI scatter/gather support: X server (root) only */
+extern int           drmScatterGatherAlloc(int fd, unsigned long size,
+					   drm_handle_t *handle);
+extern int           drmScatterGatherFree(int fd, drm_handle_t handle);
+
+extern int           drmWaitVBlank(int fd, drmVBlankPtr vbl);
+
+/* Support routines */
+extern void          drmSetServerInfo(drmServerInfoPtr info);
+extern int           drmError(int err, const char *label);
+extern void          *drmMalloc(int size);
+extern void          drmFree(void *pt);
+
+/* Hash table routines */
+extern void *drmHashCreate(void);
+extern int  drmHashDestroy(void *t);
+extern int  drmHashLookup(void *t, unsigned long key, void **value);
+extern int  drmHashInsert(void *t, unsigned long key, void *value);
+extern int  drmHashDelete(void *t, unsigned long key);
+extern int  drmHashFirst(void *t, unsigned long *key, void **value);
+extern int  drmHashNext(void *t, unsigned long *key, void **value);
+
+/* PRNG routines */
+extern void          *drmRandomCreate(unsigned long seed);
+extern int           drmRandomDestroy(void *state);
+extern unsigned long drmRandom(void *state);
+extern double        drmRandomDouble(void *state);
+
+/* Skip list routines */
+
+extern void *drmSLCreate(void);
+extern int  drmSLDestroy(void *l);
+extern int  drmSLLookup(void *l, unsigned long key, void **value);
+extern int  drmSLInsert(void *l, unsigned long key, void *value);
+extern int  drmSLDelete(void *l, unsigned long key);
+extern int  drmSLNext(void *l, unsigned long *key, void **value);
+extern int  drmSLFirst(void *l, unsigned long *key, void **value);
+extern void drmSLDump(void *l);
+extern int  drmSLLookupNeighbors(void *l, unsigned long key,
+				 unsigned long *prev_key, void **prev_value,
+				 unsigned long *next_key, void **next_value);
+
+extern int drmOpenOnce(void *unused, const char *BusID, int *newlyopened);
+extern int drmOpenOnceWithType(const char *BusID, int *newlyopened, int type);
+extern void drmCloseOnce(int fd);
+extern void drmMsg(const char *format, ...) DRM_PRINTFLIKE(1, 2);
+
+extern int drmSetMaster(int fd);
+extern int drmDropMaster(int fd);
+extern int drmIsMaster(int fd);
+
+#define DRM_EVENT_CONTEXT_VERSION 4
+
+typedef struct _drmEventContext {
+
+	/* This struct is versioned so we can add more pointers if we
+	 * add more events. */
+	int version;
+
+	void (*vblank_handler)(int fd,
+			       unsigned int sequence, 
+			       unsigned int tv_sec,
+			       unsigned int tv_usec,
+			       void *user_data);
+
+	void (*page_flip_handler)(int fd,
+				  unsigned int sequence,
+				  unsigned int tv_sec,
+				  unsigned int tv_usec,
+				  void *user_data);
+
+	void (*page_flip_handler2)(int fd,
+				   unsigned int sequence,
+				   unsigned int tv_sec,
+				   unsigned int tv_usec,
+				   unsigned int crtc_id,
+				   void *user_data);
+
+	void (*sequence_handler)(int fd,
+				 uint64_t sequence,
+				 uint64_t ns,
+				 uint64_t user_data);
+} drmEventContext, *drmEventContextPtr;
+
+extern int drmHandleEvent(int fd, drmEventContextPtr evctx);
+
+extern char *drmGetDeviceNameFromFd(int fd);
+
+/* Improved version of drmGetDeviceNameFromFd which attributes for any type of
+ * device/node - card, control or renderD.
+ */
+extern char *drmGetDeviceNameFromFd2(int fd);
+extern int drmGetNodeTypeFromFd(int fd);
+
+extern int drmPrimeHandleToFD(int fd, uint32_t handle, uint32_t flags, int *prime_fd);
+extern int drmPrimeFDToHandle(int fd, int prime_fd, uint32_t *handle);
+
+extern char *drmGetPrimaryDeviceNameFromFd(int fd);
+extern char *drmGetRenderDeviceNameFromFd(int fd);
+
+#define DRM_BUS_PCI       0
+#define DRM_BUS_USB       1
+#define DRM_BUS_PLATFORM  2
+#define DRM_BUS_HOST1X    3
+
+typedef struct _drmPciBusInfo {
+    uint16_t domain;
+    uint8_t bus;
+    uint8_t dev;
+    uint8_t func;
+} drmPciBusInfo, *drmPciBusInfoPtr;
+
+typedef struct _drmPciDeviceInfo {
+    uint16_t vendor_id;
+    uint16_t device_id;
+    uint16_t subvendor_id;
+    uint16_t subdevice_id;
+    uint8_t revision_id;
+} drmPciDeviceInfo, *drmPciDeviceInfoPtr;
+
+typedef struct _drmUsbBusInfo {
+    uint8_t bus;
+    uint8_t dev;
+} drmUsbBusInfo, *drmUsbBusInfoPtr;
+
+typedef struct _drmUsbDeviceInfo {
+    uint16_t vendor;
+    uint16_t product;
+} drmUsbDeviceInfo, *drmUsbDeviceInfoPtr;
+
+#define DRM_PLATFORM_DEVICE_NAME_LEN 512
+
+typedef struct _drmPlatformBusInfo {
+    char fullname[DRM_PLATFORM_DEVICE_NAME_LEN];
+} drmPlatformBusInfo, *drmPlatformBusInfoPtr;
+
+typedef struct _drmPlatformDeviceInfo {
+    char **compatible; /* NULL terminated list of compatible strings */
+} drmPlatformDeviceInfo, *drmPlatformDeviceInfoPtr;
+
+#define DRM_HOST1X_DEVICE_NAME_LEN 512
+
+typedef struct _drmHost1xBusInfo {
+    char fullname[DRM_HOST1X_DEVICE_NAME_LEN];
+} drmHost1xBusInfo, *drmHost1xBusInfoPtr;
+
+typedef struct _drmHost1xDeviceInfo {
+    char **compatible; /* NULL terminated list of compatible strings */
+} drmHost1xDeviceInfo, *drmHost1xDeviceInfoPtr;
+
+typedef struct _drmDevice {
+    char **nodes; /* DRM_NODE_MAX sized array */
+    int available_nodes; /* DRM_NODE_* bitmask */
+    int bustype;
+    union {
+        drmPciBusInfoPtr pci;
+        drmUsbBusInfoPtr usb;
+        drmPlatformBusInfoPtr platform;
+        drmHost1xBusInfoPtr host1x;
+    } businfo;
+    union {
+        drmPciDeviceInfoPtr pci;
+        drmUsbDeviceInfoPtr usb;
+        drmPlatformDeviceInfoPtr platform;
+        drmHost1xDeviceInfoPtr host1x;
+    } deviceinfo;
+} drmDevice, *drmDevicePtr;
+
+extern int drmGetDevice(int fd, drmDevicePtr *device);
+extern void drmFreeDevice(drmDevicePtr *device);
+
+extern int drmGetDevices(drmDevicePtr devices[], int max_devices);
+extern void drmFreeDevices(drmDevicePtr devices[], int count);
+
+#define DRM_DEVICE_GET_PCI_REVISION (1 << 0)
+extern int drmGetDevice2(int fd, uint32_t flags, drmDevicePtr *device);
+extern int drmGetDevices2(uint32_t flags, drmDevicePtr devices[], int max_devices);
+
+extern int drmDevicesEqual(drmDevicePtr a, drmDevicePtr b);
+
+extern int drmSyncobjCreate(int fd, uint32_t flags, uint32_t *handle);
+extern int drmSyncobjDestroy(int fd, uint32_t handle);
+extern int drmSyncobjHandleToFD(int fd, uint32_t handle, int *obj_fd);
+extern int drmSyncobjFDToHandle(int fd, int obj_fd, uint32_t *handle);
+
+extern int drmSyncobjImportSyncFile(int fd, uint32_t handle, int sync_file_fd);
+extern int drmSyncobjExportSyncFile(int fd, uint32_t handle, int *sync_file_fd);
+extern int drmSyncobjWait(int fd, uint32_t *handles, unsigned num_handles,
+			  int64_t timeout_nsec, unsigned flags,
+			  uint32_t *first_signaled);
+extern int drmSyncobjReset(int fd, const uint32_t *handles, uint32_t handle_count);
+extern int drmSyncobjSignal(int fd, const uint32_t *handles, uint32_t handle_count);
+extern int drmSyncobjTimelineSignal(int fd, const uint32_t *handles,
+				    uint64_t *points, uint32_t handle_count);
+extern int drmSyncobjTransfer(int fd, uint32_t dst_handle, uint64_t dst_point,
+			      uint32_t src_handle, uint64_t src_point, uint32_t flags);
+extern int drmSyncobjTimelineWait(int fd, uint32_t *handles, uint64_t *points,
+				  unsigned num_handles, int64_t timeout_nsec,
+				  unsigned flags, uint32_t *first_signaled);
+extern int drmSyncobjQuery(int fd, uint32_t *handles, uint64_t *points,
+			   uint32_t handle_count);
+extern int drmSyncobjQuery2(int fd, uint32_t *handles, uint64_t *points,
+			   uint32_t handle_count, uint32_t flags);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif
diff --git a/src/gallium/drivers/virgl/meson.build b/src/gallium/drivers/virgl/meson.build
index 0bb26c67c7c..22b8f905f32 100644
--- a/src/gallium/drivers/virgl/meson.build
+++ b/src/gallium/drivers/virgl/meson.build
@@ -43,7 +43,7 @@ libvirgl = static_library(
 
 driver_virgl = declare_dependency(
   compile_args : '-DGALLIUM_VIRGL',
-  link_with : [libvirgl, libvirgldrm, libvirglvtest],
+  link_with : [libvirgl, libvirgldrm],
 )
 
 if with_tests
diff --git a/src/gallium/drivers/virgl/virgl_context.c b/src/gallium/drivers/virgl/virgl_context.c
index 40d1155bea7..32ae912c0b3 100644
--- a/src/gallium/drivers/virgl/virgl_context.c
+++ b/src/gallium/drivers/virgl/virgl_context.c
@@ -21,7 +21,9 @@
  * USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
+#ifndef _WIN32
 #include <libsync.h>
+#endif
 #include "pipe/p_shader_tokens.h"
 
 #include "compiler/nir/nir.h"
@@ -1363,8 +1365,13 @@ static void virgl_create_fence_fd(struct pipe_context *ctx,
    assert(type == PIPE_FD_TYPE_NATIVE_SYNC);
    struct virgl_screen *rs = virgl_screen(ctx->screen);
 
-   if (rs->vws->cs_create_fence)
+   if (rs->vws->cs_create_fence) {
+#ifdef _WIN32
+      _debug_printf("virgl_create_fence_fd not support on windows\n");
+#else
       *fence = rs->vws->cs_create_fence(rs->vws, fd);
+#endif
+   }
 }
 
 static void virgl_fence_server_sync(struct pipe_context *ctx,
diff --git a/src/gallium/drivers/virgl/virgl_resource.c b/src/gallium/drivers/virgl/virgl_resource.c
index 43f92af6923..bc0048767a1 100644
--- a/src/gallium/drivers/virgl/virgl_resource.c
+++ b/src/gallium/drivers/virgl/virgl_resource.c
@@ -23,6 +23,7 @@
 #include "util/format/u_format.h"
 #include "util/u_inlines.h"
 #include "util/u_memory.h"
+#include "util/u_helpers.h"
 #include "util/u_upload_mgr.h"
 #include "virgl_context.h"
 #include "virgl_resource.h"
@@ -36,6 +37,9 @@
  */
 #define VIRGL_QUEUED_STAGING_RES_SIZE_LIMIT (128 * 1024 * 1024)
 
+// staging switch from driver
+static bool staging = false;
+
 enum virgl_transfer_map_type {
    VIRGL_TRANSFER_MAP_ERROR = -1,
    VIRGL_TRANSFER_MAP_HW_RES,
@@ -82,10 +86,13 @@ static bool virgl_can_readback_from_scanout(struct virgl_screen *vs,
 }
 
 static bool virgl_can_use_staging(struct virgl_screen *vs,
-                                  struct virgl_resource *res)
+                                  struct virgl_resource *res,
+                                  int bind)
 {
    return (vs->caps.caps.v2.capability_bits_v2 & VIRGL_CAP_V2_COPY_TRANSFER_BOTH_DIRECTIONS) &&
-         (res->b.target != PIPE_BUFFER);
+         (res->b.target != PIPE_BUFFER) && 
+         // accelerate handling resource for display
+         (bind != (VIRGL_BIND_RENDER_TARGET | VIRGL_BIND_SAMPLER_VIEW | VIRGL_BIND_DISPLAY_TARGET));
 }
 
 static bool is_stencil_array(struct virgl_resource *res)
@@ -98,7 +105,7 @@ static bool virgl_can_copy_transfer_from_host(struct virgl_screen *vs,
                                               struct virgl_resource *res,
                                               int bind)
 {
-   return virgl_can_use_staging(vs, res) &&
+   return virgl_can_use_staging(vs, res, bind) &&
          !is_stencil_array(res) &&
          !(bind & VIRGL_BIND_SHARED) &&
          virgl_has_readback_format(&vs->base, pipe_to_virgl_format(res->b.format), false) &&
@@ -198,6 +205,12 @@ virgl_resource_transfer_prepare(struct virgl_context *vctx,
       wait = false;
    }
 
+   /* try to update staging status */
+   if (!staging) {
+      staging = vws->get_param(vws, 0x1000) == 1;
+      res->use_staging = staging && virgl_can_copy_transfer_from_host(vs, res, pipe_to_virgl_bind(vs, xfer->base.resource->bind));
+   }
+
    /* When the resource is busy but its content can be discarded, we can
     * replace its HW resource or use a staging buffer to avoid waiting.
     */
@@ -220,7 +233,7 @@ virgl_resource_transfer_prepare(struct virgl_context *vctx,
       /* discard implies no readback */
       assert(!readback);
 
-      if (can_realloc || vctx->supports_staging) {
+      if ((can_realloc || vctx->supports_staging) && staging) {
          /* Both map types have some costs.  Do them only when the resource is
           * (or will be) busy for real.  Otherwise, set wait to false.
           */
@@ -657,10 +670,19 @@ static struct pipe_resource *virgl_resource_create_front(struct pipe_screen *scr
       vbind |= VIRGL_BIND_PREFER_EMULATED_BGRA;
    }
 
-   // If renderer supports copy transfer from host, and we either have support
-   // for then for textures alloc minimum size of bo
-   // This size is not passed to the host
-   res->use_staging = virgl_can_copy_transfer_from_host(vs, res, vbind);
+   // update staging status
+   if (!staging) {
+      staging = vs->vws->get_param(vs->vws, 0x1000) == 1;
+   }
+
+   if (virgl_can_copy_transfer_from_host(vs, res, vbind)) {
+      // If renderer supports copy transfer from host, and we either have support
+      // for then for textures alloc minimum size of bo
+      // This size is not passed to the host
+      res->use_staging = staging;
+   } else {
+      res->use_staging = false;
+   }
 
    if (res->use_staging)
       alloc_size = 1;
@@ -683,6 +705,23 @@ static struct pipe_resource *virgl_resource_create_front(struct pipe_screen *scr
       return NULL;
    }
 
+#ifdef _WIN32
+   // for display
+   if (vbind == (VIRGL_BIND_RENDER_TARGET | VIRGL_BIND_SAMPLER_VIEW | VIRGL_BIND_DISPLAY_TARGET)) {
+      res->bitmap.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
+      res->bitmap.bmiHeader.biWidth = templ->width0;
+      res->bitmap.bmiHeader.biHeight= -(long)templ->height0;
+      res->bitmap.bmiHeader.biPlanes = 1;
+      res->bitmap.bmiHeader.biBitCount = util_format_get_blocksizebits(templ->format);
+      res->bitmap.bmiHeader.biCompression = BI_RGB;
+      res->bitmap.bmiHeader.biSizeImage = 0;
+      res->bitmap.bmiHeader.biXPelsPerMeter = 0;
+      res->bitmap.bmiHeader.biYPelsPerMeter = 0;
+      res->bitmap.bmiHeader.biClrUsed = 0;
+      res->bitmap.bmiHeader.biClrImportant = 0;
+   }
+#endif
+
    res->clean_mask = (1 << VR_MAX_TEXTURE_2D_LEVELS) - 1;
 
    if (templ->target == PIPE_BUFFER) {
@@ -835,6 +874,11 @@ static void virgl_buffer_subdata(struct pipe_context *pipe,
    }
 
    u_default_buffer_subdata(pipe, resource, usage, offset, size, data);
+
+   if (!virgl_screen(pipe->screen)->vws->supports_coherent) {
+      // flush cmd to update host resource immediately in case that cinema4d got dirty screens
+      virgl_flush_eq(vctx, NULL, NULL);
+   }
 }
 
 void virgl_init_context_resource_functions(struct pipe_context *ctx)
diff --git a/src/gallium/drivers/virgl/virgl_resource.h b/src/gallium/drivers/virgl/virgl_resource.h
index 3b348e67c3f..4da2d8669dc 100644
--- a/src/gallium/drivers/virgl/virgl_resource.h
+++ b/src/gallium/drivers/virgl/virgl_resource.h
@@ -24,6 +24,10 @@
 #ifndef VIRGL_RESOURCE_H
 #define VIRGL_RESOURCE_H
 
+#ifdef _WIN32
+#include <windows.h>
+#endif
+
 #include "util/u_resource.h"
 #include "util/u_range.h"
 #include "util/list.h"
@@ -55,6 +59,11 @@ struct virgl_resource {
    struct virgl_hw_res *hw_res;
    struct virgl_resource_metadata metadata;
 
+#ifdef _WIN32
+   // for gdi display
+   BITMAPINFO bitmap;
+#endif
+
    /* For PIPE_BUFFER only.  Data outside of this range are uninitialized. */
    struct util_range valid_buffer_range;
 
diff --git a/src/gallium/drivers/virgl/virgl_screen.c b/src/gallium/drivers/virgl/virgl_screen.c
index a63b7cb690a..45f26cd98dd 100644
--- a/src/gallium/drivers/virgl/virgl_screen.c
+++ b/src/gallium/drivers/virgl/virgl_screen.c
@@ -895,19 +895,16 @@ static bool virgl_is_video_format_supported(struct pipe_screen *screen,
 
 static void virgl_flush_frontbuffer(struct pipe_screen *screen,
                                     struct pipe_context *ctx,
-                                      struct pipe_resource *res,
-                                      unsigned level, unsigned layer,
+                                    struct pipe_resource *res,
+                                    unsigned level, unsigned layer,
                                     void *winsys_drawable_handle, struct pipe_box *sub_box)
 {
-   struct virgl_screen *vscreen = virgl_screen(screen);
-   struct virgl_winsys *vws = vscreen->vws;
-   struct virgl_resource *vres = virgl_resource(res);
+   struct virgl_winsys *vws = virgl_screen(screen)->vws;
    struct virgl_context *vctx = virgl_context(ctx);
 
    if (vws->flush_frontbuffer) {
       virgl_flush_eq(vctx, vctx, NULL);
-      vws->flush_frontbuffer(vws, vres->hw_res, level, layer, winsys_drawable_handle,
-                             sub_box);
+      vws->flush_frontbuffer(vws, res, level, layer, winsys_drawable_handle, sub_box);
    }
 }
 
@@ -1022,6 +1019,7 @@ static struct disk_cache *virgl_get_disk_shader_cache (struct pipe_screen *pscre
    return screen->disk_cache;
 }
 
+#ifdef ENABLE_SHADER_CACHE
 static void virgl_disk_cache_create(struct virgl_screen *screen)
 {
    const struct build_id_note *note =
@@ -1050,6 +1048,7 @@ static void virgl_disk_cache_create(struct virgl_screen *screen)
 
    screen->disk_cache = disk_cache_create("virgl", timestamp, 0);
 }
+#endif
 
 static bool
 virgl_is_dmabuf_modifier_supported(UNUSED struct pipe_screen *pscreen,
@@ -1080,14 +1079,18 @@ fixup_renderer(union virgl_caps *caps)
    if (caps->v2.host_feature_check_version < 5)
       return;
 
-   char renderer[64];
-   int renderer_len = snprintf(renderer, sizeof(renderer), "virgl (%s)",
-                               caps->v2.renderer);
-   if (renderer_len >= 64) {
-      memcpy(renderer + 59, "...)", 4);
-      renderer_len = 63;
-   }
-   memcpy(caps->v2.renderer, renderer, renderer_len + 1);
+   // char renderer[64];
+   // int renderer_len = snprintf(renderer, sizeof(renderer), "virgl (%s)",
+   //                             caps->v2.renderer);
+   // if (renderer_len >= 64) {
+   //    memcpy(renderer + 59, "...)", 4);
+   //    renderer_len = 63;
+   // }
+   // memcpy(caps->v2.renderer, renderer, renderer_len + 1);
+
+   // hide host gpu information
+   char renderer[] = "Mvisor VGPU";
+   memcpy(caps->v2.renderer, renderer, sizeof(renderer));
 }
 
 static const void *
@@ -1100,6 +1103,16 @@ virgl_get_compiler_options(struct pipe_screen *pscreen,
    return &vscreen->compiler_options;
 }
 
+static void virgl_create_fence_win32(struct pipe_screen *screen,
+                              struct pipe_fence_handle **fence,
+                              void *handle,
+                              const void *name,
+                              enum pipe_fd_type type)
+{
+   _debug_printf("virgl_create_fence_win32 not support, handle=%p name=%s type=%d\n", handle, name, type);
+   assert(0);
+}
+
 struct pipe_screen *
 virgl_create_screen(struct virgl_winsys *vws, const struct pipe_screen_config *config)
 {
@@ -1149,6 +1162,7 @@ virgl_create_screen(struct virgl_winsys *vws, const struct pipe_screen_config *c
    screen->base.flush_frontbuffer = virgl_flush_frontbuffer;
    screen->base.get_timestamp = u_default_get_timestamp;
    screen->base.fence_reference = virgl_fence_reference;
+   screen->base.create_fence_win32 = virgl_create_fence_win32;
    //screen->base.fence_signalled = virgl_fence_signalled;
    screen->base.fence_finish = virgl_fence_finish;
    screen->base.fence_get_fd = virgl_fence_get_fd;
@@ -1186,6 +1200,8 @@ virgl_create_screen(struct virgl_winsys *vws, const struct pipe_screen_config *c
 
    slab_create_parent(&screen->transfer_pool, sizeof(struct virgl_transfer), 16);
 
+#ifdef ENABLE_SHADER_CACHE
    virgl_disk_cache_create(screen);
+#endif
    return &screen->base;
 }
diff --git a/src/gallium/drivers/virgl/virgl_video.c b/src/gallium/drivers/virgl/virgl_video.c
index f5aa89db141..a98459cd810 100644
--- a/src/gallium/drivers/virgl/virgl_video.c
+++ b/src/gallium/drivers/virgl/virgl_video.c
@@ -66,7 +66,9 @@
  */
 
 #include <string.h>
+#ifndef _WIN32
 #include <sys/param.h>
+#endif
 
 #include "vl/vl_decoder.h"
 #include "vl/vl_video_buffer.h"
@@ -106,7 +108,7 @@ static int fill_base_picture_desc(const struct pipe_picture_desc *desc,
     ITEM_SET(vbase, desc, protected_playback);
     ITEM_SET(vbase, desc, key_size);
     memcpy(vbase->decrypt_key, desc->decrypt_key,
-           MIN(desc->key_size, sizeof(vbase->decrypt_key)));
+           MIN2(desc->key_size, sizeof(vbase->decrypt_key)));
 
     return 0;
 }
diff --git a/src/gallium/drivers/virgl/virgl_winsys.h b/src/gallium/drivers/virgl/virgl_winsys.h
index 13e82b033b4..c2ffbf9888b 100644
--- a/src/gallium/drivers/virgl/virgl_winsys.h
+++ b/src/gallium/drivers/virgl/virgl_winsys.h
@@ -52,6 +52,8 @@ struct virgl_winsys {
 
    void (*destroy)(struct virgl_winsys *vws);
 
+   uint64_t (*get_param)(struct virgl_winsys *vws, uint64_t param);
+
    int (*transfer_put)(struct virgl_winsys *vws,
                        struct virgl_hw_res *res,
                        const struct pipe_box *box,
@@ -131,10 +133,11 @@ struct virgl_winsys {
 
    /* for sw paths */
    void (*flush_frontbuffer)(struct virgl_winsys *vws,
-                             struct virgl_hw_res *res,
+                             struct pipe_resource *res,
                              unsigned level, unsigned layer,
                              void *winsys_drawable_handle,
                              struct pipe_box *sub_box);
+
    void (*fence_server_sync)(struct virgl_winsys *vws,
                              struct virgl_cmd_buf *cbuf,
                              struct pipe_fence_handle *fence);
diff --git a/src/gallium/meson.build b/src/gallium/meson.build
index 7b77da14f30..4f571a944a1 100644
--- a/src/gallium/meson.build
+++ b/src/gallium/meson.build
@@ -152,9 +152,9 @@ else
   driver_svga = declare_dependency()
 endif
 if with_gallium_virgl
+  subdir('winsys/virgl/lib')
   subdir('winsys/virgl/common')
   subdir('winsys/virgl/drm')
-  subdir('winsys/virgl/vtest')
   subdir('drivers/virgl')
 else
   driver_virgl = declare_dependency()
diff --git a/src/gallium/targets/wgl/meson.build b/src/gallium/targets/wgl/meson.build
index eaca0aec86b..433d24ed395 100644
--- a/src/gallium/targets/wgl/meson.build
+++ b/src/gallium/targets/wgl/meson.build
@@ -41,7 +41,7 @@ libgallium_wgl = shared_library(
     libgallium, libglsl, libmesa, libwsgdi, libglapi_static, libglapi, libgalliumvl
   ],
   dependencies : [
-    dep_ws2_32, idep_nir, idep_mesautil, driver_swrast,
+    dep_ws2_32, idep_nir, idep_mesautil, driver_swrast, driver_virgl,
     driver_d3d12, driver_zink, winsys_d3d12_wgl
   ],
   link_args : gallium_wgl_link_args,
diff --git a/src/gallium/targets/wgl/wgl.c b/src/gallium/targets/wgl/wgl.c
index da44e146488..7e88a28d21c 100644
--- a/src/gallium/targets/wgl/wgl.c
+++ b/src/gallium/targets/wgl/wgl.c
@@ -43,6 +43,10 @@
 #include "pipe/p_screen.h"
 #include "pipe/p_context.h"
 
+#if defined(GALLIUM_VIRGL) && defined(_WIN32)
+#include "../../winsys/virgl/lib/vgpu_api.h"
+#endif
+
 #ifdef GALLIUM_SOFTPIPE
 #include "softpipe/sp_texture.h"
 #include "softpipe/sp_screen.h"
@@ -63,6 +67,10 @@
 #include "zink/zink_public.h"
 #endif
 
+#if defined(GALLIUM_VIRGL) && defined(_WIN32)
+#include "virgl/drm/virgl_drm_public.h"
+#endif
+
 #ifdef GALLIUM_LLVMPIPE
 static boolean use_llvmpipe = FALSE;
 #endif
@@ -72,6 +80,10 @@ static boolean use_d3d12 = FALSE;
 #ifdef GALLIUM_ZINK
 static boolean use_zink = FALSE;
 #endif
+#if defined(GALLIUM_VIRGL) && defined(_WIN32)
+static boolean use_virgl = FALSE;
+static HANDLE vgpu_handle = INVALID_HANDLE_VALUE;
+#endif
 
 static const char *created_driver_name = NULL;
 
@@ -107,6 +119,13 @@ wgl_screen_create_by_name(HDC hDC, const char* driver, struct sw_winsys *winsys)
    }
 #endif
 
+#if defined(GALLIUM_VIRGL) && defined(_WIN32)
+   if (strcmp(driver, "virgl") == 0) {
+      vgpu_handle = GetHandleFromVgpu();
+      screen = virgl_drm_screen_create(vgpu_handle, NULL, winsys);
+      use_virgl = TRUE;
+   }
+#endif
    return screen;
 }
 
@@ -133,6 +152,9 @@ wgl_screen_create(HDC hDC)
 #endif
 #if defined(GALLIUM_SOFTPIPE)
       "softpipe",
+#endif
+#if defined(GALLIUM_VIRGL) && defined(_WIN32)
+      "virgl",
 #endif
    };
 
@@ -143,6 +165,7 @@ wgl_screen_create(HDC hDC)
       struct pipe_screen* screen = wgl_screen_create_by_name(hDC, drivers[i], winsys);
       if (screen) {
          created_driver_name = drivers[i];
+         _debug_printf("create screen from %s\n", created_driver_name);
          return screen;
       }
       if (i == 0 && drivers[i][0] != '\0')
@@ -203,6 +226,13 @@ wgl_present(struct pipe_screen *screen,
    dt = softpipe_resource(res)->dt,
    gdi_sw_display(winsys, dt, hDC);
 #endif
+
+#if defined(GALLIUM_VIRGL) && defined(_WIN32)
+   if (use_virgl) {
+      screen->flush_frontbuffer(screen, ctx, res, 0, 0, hDC, NULL);
+      return;
+   }
+#endif
 }
 
 
@@ -277,6 +307,7 @@ DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
 {
    switch (fdwReason) {
    case DLL_PROCESS_ATTACH:
+      _debug_printf("call DLL_PROCESS_ATTACH\n");
       stw_init(&stw_winsys);
       stw_init_thread();
       break;
@@ -290,6 +321,12 @@ DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
       break;
 
    case DLL_PROCESS_DETACH:
+      _debug_printf("call DLL_PROCESS_DETACH\n");
+#if defined(GALLIUM_VIRGL) && defined(_WIN32)
+      if (vgpu_handle != INVALID_HANDLE_VALUE) {
+         DestroyVirglContext(vgpu_handle);
+      }
+#endif
       if (lpvReserved == NULL) {
          // We're being unloaded from the process.
          stw_cleanup_thread();
diff --git a/src/gallium/winsys/virgl/drm/meson.build b/src/gallium/winsys/virgl/drm/meson.build
index 79bac2fd211..bd1f4712261 100644
--- a/src/gallium/winsys/virgl/drm/meson.build
+++ b/src/gallium/winsys/virgl/drm/meson.build
@@ -22,6 +22,6 @@ libvirgldrm = static_library(
   'virgldrm',
   'virgl_drm_winsys.c',
   include_directories : [inc_include, inc_src, inc_mapi, inc_mesa, inc_gallium, inc_gallium_aux, inc_gallium_drivers, inc_virtio],
-  dependencies : [dep_libdrm, dep_libvirglcommon, idep_mesautil, idep_nir_headers],
+  dependencies : [dep_libdrm, dep_libvirglcommon, idep_mesautil, idep_nir_headers, dep_libvgpuapi],
   gnu_symbol_visibility : 'hidden',
 )
diff --git a/src/gallium/winsys/virgl/drm/virgl_drm_public.h b/src/gallium/winsys/virgl/drm/virgl_drm_public.h
index 32df3945ff4..8c9d9bfa94b 100644
--- a/src/gallium/winsys/virgl/drm/virgl_drm_public.h
+++ b/src/gallium/winsys/virgl/drm/virgl_drm_public.h
@@ -25,6 +25,10 @@
 
 struct pipe_screen;
 
-struct pipe_screen *virgl_drm_screen_create(int fd, const struct pipe_screen_config *config);
+#ifdef _WIN32
+struct pipe_screen *virgl_drm_screen_create(HANDLE fd, const struct pipe_screen_config *config, struct sw_winsys *winsys);
+#else
+struct pipe_screen *virgl_drm_screen_create(int fd, const struct pipe_screen_config *config, struct sw_winsys *winsys);
+#endif
 
 #endif
diff --git a/src/gallium/winsys/virgl/drm/virgl_drm_winsys.c b/src/gallium/winsys/virgl/drm/virgl_drm_winsys.c
index 6ae63e75758..38498997840 100644
--- a/src/gallium/winsys/virgl/drm/virgl_drm_winsys.c
+++ b/src/gallium/winsys/virgl/drm/virgl_drm_winsys.c
@@ -25,10 +25,15 @@
 #include <fcntl.h>
 #include <limits.h>
 #include <stdio.h>
+
+#ifdef _WIN32
+#include <windows.h>
+#else
 #include <sys/ioctl.h>
 #include <sys/stat.h>
 
 #include "util/os_mman.h"
+#endif
 #include "util/os_file.h"
 #include "util/os_time.h"
 #include "util/u_memory.h"
@@ -37,17 +42,29 @@
 #include "util/u_inlines.h"
 #include "util/u_pointer.h"
 #include "frontend/drm_driver.h"
+#ifdef _WIN32
+#include "frontend/sw_winsys.h"
+#include "virgl/virgl_resource.h"
+#endif
 #include "virgl/virgl_screen.h"
 #include "virgl/virgl_public.h"
 #include "virtio-gpu/virgl_protocol.h"
 
+#ifndef _WIN32
 #include <xf86drm.h>
 #include <libsync.h>
+#endif
 #include "drm-uapi/virtgpu_drm.h"
 
 #include "virgl_drm_winsys.h"
 #include "virgl_drm_public.h"
 
+#ifdef _WIN32
+#include "../lib/vgpu_api.h"
+#endif
+
+#define PAGE_SIZE 4096
+
 // Delete local definitions when virglrenderer_hw.h becomes public
 #define VIRGL_DRM_CAPSET_VIRGL  1
 #define VIRGL_DRM_CAPSET_VIRGL2 2
@@ -93,8 +110,14 @@ static void virgl_hw_res_destroy(struct virgl_drm_winsys *qdws,
          _mesa_hash_table_remove_key(qdws->bo_names,
                                 (void *)(uintptr_t)res->flink_name);
       mtx_unlock(&qdws->bo_handles_mutex);
-      if (res->ptr)
+
+      if (res->ptr) {
+#ifdef _WIN32
+         // unmap resource in driver
+#else
          os_munmap(res->ptr, res->size);
+#endif
+      }
 
       memset(&args, 0, sizeof(args));
       args.handle = res->bo_handle;
@@ -117,8 +140,14 @@ static boolean virgl_drm_resource_is_busy(struct virgl_winsys *vws,
    waitcmd.flags = VIRTGPU_WAIT_NOWAIT;
 
    ret = drmIoctl(vdws->fd, DRM_IOCTL_VIRTGPU_WAIT, &waitcmd);
+
+#ifdef _WIN32
+   if (ret == 1)
+      return TRUE;
+#else
    if (ret && errno == EBUSY)
       return TRUE;
+#endif
 
    p_atomic_set(&res->maybe_busy, false);
 
@@ -161,6 +190,85 @@ static void virgl_drm_resource_reference(struct virgl_winsys *qws,
    *dres = sres;
 }
 
+#ifdef _WIN32
+static struct virgl_hw_res *
+virgl_drm_winsys_resource_create_blob(struct virgl_winsys *qws,
+                                      enum pipe_texture_target target,
+                                      uint32_t format,
+                                      uint32_t bind,
+                                      uint32_t width,
+                                      uint32_t height,
+                                      uint32_t depth,
+                                      uint32_t array_size,
+                                      uint32_t last_level,
+                                      uint32_t nr_samples,
+                                      uint32_t flags,
+                                      uint32_t size)
+{
+   int ret;
+   int32_t blob_id;
+   struct virgl_drm_winsys *qdws = virgl_drm_winsys(qws);
+   struct drm_virtgpu_resource_create_blob drm_rc_blob = { 0 };
+   struct virgl_hw_res *res;
+   struct virgl_resource_params params = { .size = size,
+                                           .bind = bind,
+                                           .format = format,
+                                           .flags = flags,
+                                           .nr_samples = nr_samples,
+                                           .width = width,
+                                           .height = height,
+                                           .depth = depth,
+                                           .array_size = array_size,
+                                           .last_level = last_level,
+                                           .target = target };
+
+   res = CALLOC_STRUCT(virgl_hw_res);
+   if (!res)
+      return NULL;
+
+   /* Make sure blob is page aligned. */
+   if (flags & (VIRGL_RESOURCE_FLAG_MAP_PERSISTENT |
+                VIRGL_RESOURCE_FLAG_MAP_COHERENT)) {
+      width = ALIGN(width, PAGE_SIZE);
+      size = ALIGN(size, PAGE_SIZE);
+   }
+
+   blob_id = p_atomic_inc_return(&qdws->blob_id);
+
+   drm_rc_blob.format = format;
+   drm_rc_blob.bind = bind;
+   drm_rc_blob.target = target;
+   drm_rc_blob.width = width;
+   drm_rc_blob.height = height;
+   drm_rc_blob.depth = depth;
+   drm_rc_blob.array_size = array_size;
+   drm_rc_blob.last_level = last_level;
+   drm_rc_blob.nr_samples = nr_samples;
+   drm_rc_blob.flags = flags;
+   drm_rc_blob.size = size;
+   drm_rc_blob.blob_mem = VIRTGPU_BLOB_MEM_HOST3D;
+   drm_rc_blob.blob_flags = VIRTGPU_BLOB_FLAG_USE_MAPPABLE;
+   drm_rc_blob.blob_id = (uint64_t) blob_id;
+
+   ret = drmIoctl(qdws->fd, DRM_IOCTL_VIRTGPU_RESOURCE_CREATE_BLOB, &drm_rc_blob);
+   if (ret != 0) {
+      FREE(res);
+      return NULL;
+   }
+
+   res->bind = bind;
+   res->res_handle = drm_rc_blob.res_handle;
+   res->bo_handle = drm_rc_blob.bo_handle;
+   res->size = size;
+   res->flags = flags;
+   res->maybe_untyped = false;
+   pipe_reference_init(&res->reference, 1);
+   p_atomic_set(&res->external, false);
+   p_atomic_set(&res->num_cs_references, 0);
+   virgl_resource_cache_entry_init(&res->cache_entry, params);
+   return res;
+}
+#else
 static struct virgl_hw_res *
 virgl_drm_winsys_resource_create_blob(struct virgl_winsys *qws,
                                       enum pipe_texture_target target,
@@ -218,7 +326,7 @@ virgl_drm_winsys_resource_create_blob(struct virgl_winsys *qws,
    cmd[VIRGL_PIPE_RES_CREATE_FLAGS] = flags;
    cmd[VIRGL_PIPE_RES_CREATE_BLOB_ID] = blob_id;
 
-   drm_rc_blob.cmd = (unsigned long)(void *)&cmd;
+   drm_rc_blob.cmd = (uint64_t)(void *)&cmd;
    drm_rc_blob.cmd_size = 4 * (VIRGL_PIPE_RES_CREATE_SIZE + 1);
    drm_rc_blob.size = size;
    drm_rc_blob.blob_mem = VIRTGPU_BLOB_MEM_HOST3D;
@@ -243,6 +351,7 @@ virgl_drm_winsys_resource_create_blob(struct virgl_winsys *qws,
    virgl_resource_cache_entry_init(&res->cache_entry, params);
    return res;
 }
+#endif
 
 static struct virgl_hw_res *
 virgl_drm_winsys_resource_create(struct virgl_winsys *qws,
@@ -317,6 +426,8 @@ virgl_drm_winsys_resource_create(struct virgl_winsys *qws,
 
    virgl_resource_cache_entry_init(&res->cache_entry, params);
 
+   // _debug_printf("create resource id=%d bind=%d target=%d size=%d\n", res->res_handle, res->bind, res->target, size);
+
    return res;
 }
 
@@ -475,6 +586,12 @@ virgl_drm_winsys_resource_create_handle(struct virgl_winsys *qws,
                                         uint64_t *modifier,
                                         uint32_t *blob_mem)
 {
+#ifdef _WIN32
+   _debug_printf("virgl_drm_winsys_resource_create_handle not implememt\n");
+   assert(0);
+   return NULL;
+#else
+
    struct virgl_drm_winsys *qdws = virgl_drm_winsys(qws);
    struct drm_gem_open open_arg = {};
    struct drm_virtgpu_resource_info info_arg = {};
@@ -573,6 +690,7 @@ virgl_drm_winsys_resource_create_handle(struct virgl_winsys *qws,
 done:
    mtx_unlock(&qdws->bo_handles_mutex);
    return res;
+#endif
 }
 
 static void
@@ -632,6 +750,12 @@ static boolean virgl_drm_winsys_resource_get_handle(struct virgl_winsys *qws,
                                                     uint32_t stride,
                                                     struct winsys_handle *whandle)
  {
+#ifdef _WIN32
+   _debug_printf("virgl_drm_winsys_resource_get_handle not implememt\n");
+   assert(0);
+   return FALSE;
+#else
+
    struct virgl_drm_winsys *qdws = virgl_drm_winsys(qws);
    struct drm_gem_flink flink;
 
@@ -667,6 +791,7 @@ static boolean virgl_drm_winsys_resource_get_handle(struct virgl_winsys *qws,
 
    whandle->stride = stride;
    return TRUE;
+#endif
 }
 
 static void *virgl_drm_resource_map(struct virgl_winsys *qws,
@@ -684,10 +809,14 @@ static void *virgl_drm_resource_map(struct virgl_winsys *qws,
    if (drmIoctl(qdws->fd, DRM_IOCTL_VIRTGPU_MAP, &mmap_arg))
       return NULL;
 
+#ifdef _WIN32
+   ptr = (void*)mmap_arg.offset;
+#else
    ptr = os_mmap(0, res->size, PROT_READ|PROT_WRITE, MAP_SHARED,
                  qdws->fd, mmap_arg.offset);
    if (ptr == MAP_FAILED)
       return NULL;
+#endif
 
    res->ptr = ptr;
    return ptr;
@@ -871,7 +1000,11 @@ static struct virgl_cmd_buf *virgl_drm_cmd_buf_create(struct virgl_winsys *qws,
       return NULL;
    }
 
+#ifdef _WIN32
+   cbuf->in_fence_fd = NULL;
+#else
    cbuf->in_fence_fd = -1;
+#endif
    cbuf->base.buf = cbuf->buf;
    return &cbuf->base;
 }
@@ -887,21 +1020,34 @@ static void virgl_drm_cmd_buf_destroy(struct virgl_cmd_buf *_cbuf)
 }
 
 static struct pipe_fence_handle *
-virgl_drm_fence_create(struct virgl_winsys *vws, int fd, bool external)
+#ifdef _WIN32
+   virgl_drm_fence_create(struct virgl_winsys *vws, HANDLE fd, bool external)
+#else
+   virgl_drm_fence_create(struct virgl_winsys *vws, int fd, bool external)
+#endif
 {
    struct virgl_drm_fence *fence;
 
    assert(vws->supports_fences);
 
+#ifdef _WIN32
+   // external fd not implement
+   assert(!external);
+#else
    if (external) {
       fd = os_dupfd_cloexec(fd);
       if (fd < 0)
          return NULL;
    }
+#endif
 
    fence = CALLOC_STRUCT(virgl_drm_fence);
    if (!fence) {
+#ifdef _WIN32
+      CloseHandle(fd);
+#else
       close(fd);
+#endif
       return NULL;
    }
 
@@ -923,7 +1069,11 @@ virgl_drm_fence_create_legacy(struct virgl_winsys *vws)
    fence = CALLOC_STRUCT(virgl_drm_fence);
    if (!fence)
       return NULL;
+#ifdef _WIN32
+   fence->fd = NULL;
+#else
    fence->fd = -1;
+#endif
 
    /* Resources for fences should not be from the cache, since we are basing
     * the fence status on the resource creation busy status.
@@ -953,13 +1103,28 @@ static int virgl_drm_winsys_submit_cmd(struct virgl_winsys *qws,
       return 0;
 
    memset(&eb, 0, sizeof(struct drm_virtgpu_execbuffer));
-   eb.command = (unsigned long)(void*)cbuf->buf;
+   eb.command = (uint64_t)(void*)cbuf->buf;
    eb.size = cbuf->base.cdw * 4;
    eb.num_bo_handles = cbuf->cres;
-   eb.bo_handles = (unsigned long)(void *)cbuf->res_hlist;
+   eb.bo_handles = (uint64_t)(void *)cbuf->res_hlist;
 
-   eb.fence_fd = -1;
+#ifdef _WIN32
    if (qws->supports_fences) {
+      if (cbuf->in_fence_fd != NULL) {
+         eb.in_fence_fd = cbuf->in_fence_fd;
+         eb.flags |= VIRTGPU_EXECBUF_FENCE_FD_IN;
+      }
+
+      if (fence != NULL) {
+         eb.out_fence_fd = CreateEvent(NULL, TRUE, FALSE, NULL);
+         eb.flags |= VIRTGPU_EXECBUF_FENCE_FD_OUT;
+      }
+   } else {
+      assert(cbuf->in_fence_fd == NULL);
+   }
+#else
+   eb.fence_fd = -1;
+    if (qws->supports_fences) {
       if (cbuf->in_fence_fd >= 0) {
          eb.flags |= VIRTGPU_EXECBUF_FENCE_FD_IN;
          eb.fence_fd = cbuf->in_fence_fd;
@@ -970,6 +1135,7 @@ static int virgl_drm_winsys_submit_cmd(struct virgl_winsys *qws,
    } else {
       assert(cbuf->in_fence_fd < 0);
    }
+#endif
 
    ret = drmIoctl(qdws->fd, DRM_IOCTL_VIRTGPU_EXECBUFFER, &eb);
    if (ret == -1)
@@ -978,12 +1144,22 @@ static int virgl_drm_winsys_submit_cmd(struct virgl_winsys *qws,
 
    if (qws->supports_fences) {
       if (cbuf->in_fence_fd >= 0) {
+#ifdef _WIN32
+         CloseHandle(cbuf->in_fence_fd);
+         cbuf->in_fence_fd = NULL;
+#else
          close(cbuf->in_fence_fd);
          cbuf->in_fence_fd = -1;
+#endif
       }
 
       if (fence != NULL && ret == 0)
+#ifdef _WIN32
+         *fence = virgl_drm_fence_create(qws, eb.out_fence_fd, false);
+#else
          *fence = virgl_drm_fence_create(qws, eb.fence_fd, false);
+#endif
+
    } else {
       if (fence != NULL && ret == 0)
          *fence = virgl_drm_fence_create_legacy(qws);
@@ -1012,7 +1188,7 @@ static int virgl_drm_get_caps(struct virgl_winsys *vws,
       args.cap_set_id = 1;
       args.size = sizeof(struct virgl_caps_v1);
    }
-   args.addr = (unsigned long)&caps->caps;
+   args.addr = (uint64_t)&caps->caps;
 
    ret = drmIoctl(vdws->fd, DRM_IOCTL_VIRTGPU_GET_CAPS, &args);
    if (ret == -1 && errno == EINVAL) {
@@ -1023,6 +1199,8 @@ static int virgl_drm_get_caps(struct virgl_winsys *vws,
       if (ret == -1)
           return ret;
    }
+
+   _debug_printf("glsl_level=%d\n", caps->caps.v1.glsl_level);
    return ret;
 }
 
@@ -1031,8 +1209,15 @@ virgl_cs_create_fence(struct virgl_winsys *vws, int fd)
 {
    if (!vws->supports_fences)
       return NULL;
+      
+#ifdef _WIN32
+   _debug_printf("virgl_cs_create_fence not implement fd=%d\n", fd);
+   assert(0);
+   return NULL;
+#else
 
    return virgl_drm_fence_create(vws, fd, true);
+#endif
 }
 
 static bool virgl_fence_wait(struct virgl_winsys *vws,
@@ -1046,7 +1231,11 @@ static bool virgl_fence_wait(struct virgl_winsys *vws,
       int timeout_poll;
 
       if (timeout == 0)
+#ifdef _WIN32
+         return WaitForSingleObject(fence->fd, 0) == WAIT_OBJECT_0;
+#else
          return sync_wait(fence->fd, 0) == 0;
+#endif
 
       timeout_ms = timeout / 1000000;
       /* round up */
@@ -1054,8 +1243,11 @@ static bool virgl_fence_wait(struct virgl_winsys *vws,
          timeout_ms++;
 
       timeout_poll = timeout_ms <= INT_MAX ? (int) timeout_ms : -1;
-
+#ifdef _WIN32
+      return WaitForSingleObject(fence->fd, timeout_poll) == WAIT_OBJECT_0;
+#else
       return sync_wait(fence->fd, timeout_poll) == 0;
+#endif
    }
 
    if (timeout == 0)
@@ -1085,7 +1277,11 @@ static void virgl_fence_reference(struct virgl_winsys *vws,
 
    if (pipe_reference(&dfence->reference, &sfence->reference)) {
       if (vws->supports_fences) {
+#ifdef _WIN32
+         CloseHandle(dfence->fd);
+#else
          close(dfence->fd);
+#endif
       } else {
          virgl_drm_resource_reference(vws, &dfence->hw_res, NULL);
       }
@@ -1109,7 +1305,12 @@ static void virgl_fence_server_sync(struct virgl_winsys *vws,
    if (!fence->external)
       return;
 
+#ifdef _WIN32
+   cbuf->in_fence_fd = fence->fd;
+   _debug_printf("call virgl_fence_server_sync fence->fd=%d\n", fence->fd);
+#else
    sync_accumulate("virgl", &cbuf->in_fence_fd, fence->fd);
+#endif
 }
 
 static int virgl_fence_get_fd(struct virgl_winsys *vws,
@@ -1120,10 +1321,19 @@ static int virgl_fence_get_fd(struct virgl_winsys *vws,
    if (!vws->supports_fences)
       return -1;
 
+#ifdef _WIN32
+    _debug_printf("virgl_fence_get_fd not implement on windows fence->fd=%d\n", fence->fd);
+   return -1;
+#else
    return os_dupfd_cloexec(fence->fd);
+#endif
 }
 
+#ifdef _WIN32
+static int virgl_drm_get_version(HANDLE fd)
+#else
 static int virgl_drm_get_version(int fd)
+#endif
 {
 	int ret;
 	drmVersionPtr version;
@@ -1162,7 +1372,11 @@ virgl_drm_resource_cache_entry_release(struct virgl_resource_cache_entry *entry,
    virgl_hw_res_destroy(qdws, res);
 }
 
+#ifdef _WIN32
+static int virgl_init_context(HANDLE drmFD)
+#else
 static int virgl_init_context(int drmFD)
+#endif
 {
    int ret;
    struct drm_virtgpu_context_init init = { 0 };
@@ -1177,7 +1391,7 @@ static int virgl_init_context(int drmFD)
                               params[param_supported_capset_ids].value);
 
    if (!supports_capset_virgl && !supports_capset_virgl2) {
-      _debug_printf("No virgl contexts available on host");
+      _debug_printf("No virgl contexts available on host\n");
       return -EINVAL;
    }
 
@@ -1186,7 +1400,11 @@ static int virgl_init_context(int drmFD)
                          VIRGL_DRM_CAPSET_VIRGL2 :
                          VIRGL_DRM_CAPSET_VIRGL;
 
+#ifdef _WIN32
+   init.ctx_set_params = (uint64_t)(void *)&ctx_set_param;
+#else
    init.ctx_set_params = (unsigned long)(void *)&ctx_set_param;
+#endif
    init.num_params = 1;
 
    ret = drmIoctl(drmFD, DRM_IOCTL_VIRTGPU_CONTEXT_INIT, &init);
@@ -1203,6 +1421,143 @@ static int virgl_init_context(int drmFD)
    return 0;
 }
 
+#ifdef _WIN32
+static void virgl_flush_frontbuffer(struct virgl_winsys *vws,
+                                    struct pipe_resource *res,
+                                    unsigned level, unsigned layer,
+                                    void *winsys_drawable_handle, struct pipe_box *sub_box)
+{
+   struct virgl_resource *vres = virgl_resource(res);
+
+   struct pipe_box box;
+   u_box_2d_zslice(0, 0, layer, res->width0, res->height0, &box);
+
+   virgl_bo_transfer_get(vws, vres->hw_res, &box, 0, 0, 0, level);
+   virgl_drm_resource_wait(vws, vres->hw_res);
+
+   StretchDIBits((HDC)winsys_drawable_handle,
+         0, 0, res->width0, res->height0,
+         0, 0, res->width0, res->height0,
+         virgl_drm_resource_map(vws, vres->hw_res),
+         &vres->bitmap, 
+         0, 
+         SRCCOPY);
+}
+
+static uint64_t virgl_get_param(struct virgl_winsys *vws, uint64_t param)
+{
+   uint64_t value = 0;
+   struct drm_virtgpu_getparam getparam = { 0 };
+   struct virgl_drm_winsys *vdws = virgl_drm_winsys(vws);
+
+   getparam.param = param;
+   getparam.value = (uint64_t)(uintptr_t)&value;
+   if (drmIoctl(vdws->fd, DRM_IOCTL_VIRTGPU_GETPARAM, &getparam) == 0) {
+      return value;
+   } else {
+      return 0;
+   }
+}
+
+static struct virgl_winsys *
+virgl_drm_winsys_create(HANDLE drmFD)
+{
+   static const unsigned CACHE_TIMEOUT_USEC = 1000000;
+   struct virgl_drm_winsys *qdws;
+   int drm_version;
+   int ret;
+
+   qdws = CALLOC_STRUCT(virgl_drm_winsys);
+   if (!qdws)
+      return NULL;
+   qdws->fd = drmFD;
+   
+   for (uint32_t i = 0; i < ARRAY_SIZE(params); i++) {
+      params[i].value = virgl_get_param(&qdws->base, params[i].param);
+      _debug_printf("param=%d value=%ld\n", params[i].param, params[i].value);
+   }
+
+   if (!params[param_3d_features].value)
+      return NULL;
+
+   drm_version = virgl_drm_get_version(drmFD);
+   if (drm_version < 0)
+      return NULL;
+
+   if (params[param_context_init].value) {
+      ret = virgl_init_context(drmFD);
+      if (ret)
+         return NULL;
+   }
+
+   virgl_resource_cache_init(&qdws->cache, CACHE_TIMEOUT_USEC,
+                             virgl_drm_resource_cache_entry_is_busy,
+                             virgl_drm_resource_cache_entry_release,
+                             qdws);
+   (void) mtx_init(&qdws->mutex, mtx_plain);
+   (void) mtx_init(&qdws->bo_handles_mutex, mtx_plain);
+   p_atomic_set(&qdws->blob_id, 0);
+
+   qdws->bo_handles = util_hash_table_create_ptr_keys();
+   qdws->bo_names = util_hash_table_create_ptr_keys();
+   qdws->base.destroy = virgl_drm_winsys_destroy;
+
+   qdws->base.get_param = virgl_get_param;
+   qdws->base.transfer_put = virgl_bo_transfer_put;
+   qdws->base.transfer_get = virgl_bo_transfer_get;
+   qdws->base.resource_create = virgl_drm_winsys_resource_cache_create;
+   qdws->base.resource_reference = virgl_drm_resource_reference;
+   qdws->base.resource_create_from_handle = virgl_drm_winsys_resource_create_handle;
+   qdws->base.resource_set_type = virgl_drm_winsys_resource_set_type;
+   qdws->base.resource_get_handle = virgl_drm_winsys_resource_get_handle;
+   qdws->base.resource_get_storage_size = virgl_drm_winsys_resource_get_storage_size;
+   qdws->base.resource_map = virgl_drm_resource_map;
+   qdws->base.resource_wait = virgl_drm_resource_wait;
+   qdws->base.resource_is_busy = virgl_drm_resource_is_busy;
+   qdws->base.cmd_buf_create = virgl_drm_cmd_buf_create;
+   qdws->base.cmd_buf_destroy = virgl_drm_cmd_buf_destroy;
+   qdws->base.submit_cmd = virgl_drm_winsys_submit_cmd;
+   qdws->base.emit_res = virgl_drm_emit_res;
+   qdws->base.res_is_referenced = virgl_drm_res_is_ref;
+   qdws->base.flush_frontbuffer = virgl_flush_frontbuffer;
+   qdws->base.cs_create_fence = virgl_cs_create_fence;
+   qdws->base.fence_wait = virgl_fence_wait;
+   qdws->base.fence_reference = virgl_fence_reference;
+   qdws->base.fence_server_sync = virgl_fence_server_sync;
+   qdws->base.fence_get_fd = virgl_fence_get_fd;
+   qdws->base.get_caps = virgl_drm_get_caps;
+   qdws->base.supports_fences =  drm_version >= VIRGL_DRM_VERSION_FENCE_FD;
+   qdws->base.supports_encoded_transfers = 1;
+
+   qdws->base.supports_coherent = params[param_resource_blob].value &&
+                                  params[param_host_visible].value;
+   return &qdws->base;
+}
+
+static struct hash_table *fd_tab = NULL;
+static simple_mtx_t virgl_screen_mutex = SIMPLE_MTX_INITIALIZER;
+
+static void
+virgl_drm_screen_destroy(struct pipe_screen *pscreen)
+{
+   struct virgl_screen *screen = virgl_screen(pscreen);
+   boolean destroy;
+
+   simple_mtx_lock(&virgl_screen_mutex);
+   destroy = --screen->refcnt == 0;
+   if (destroy) {
+      HANDLE fd = virgl_drm_winsys(screen->vws)->fd;
+      _mesa_hash_table_remove_key(fd_tab, fd);
+      CloseHandle(fd);
+   }
+   simple_mtx_unlock(&virgl_screen_mutex);
+
+   if (destroy) {
+      pscreen->destroy = screen->winsys_priv;
+      pscreen->destroy(pscreen);
+   }
+}
+#else
 static struct virgl_winsys *
 virgl_drm_winsys_create(int drmFD)
 {
@@ -1305,6 +1660,7 @@ virgl_drm_screen_destroy(struct pipe_screen *pscreen)
       pscreen->destroy(pscreen);
    }
 }
+#endif
 
 static uint32_t
 hash_fd(const void *key)
@@ -1343,6 +1699,50 @@ equal_fd(const void *key1, const void *key2)
    return false;
 }
 
+#ifdef _WIN32
+struct pipe_screen *
+virgl_drm_screen_create(HANDLE fd, const struct pipe_screen_config *config, struct sw_winsys *winsys)
+{
+   struct pipe_screen *pscreen = NULL;
+
+   simple_mtx_lock(&virgl_screen_mutex);
+   if (!fd_tab) {
+      fd_tab = _mesa_hash_table_create(NULL, hash_fd, equal_fd);
+      if (!fd_tab)
+         goto unlock;
+   }
+
+   pscreen = util_hash_table_get(fd_tab, fd);
+   if (pscreen) {
+      virgl_screen(pscreen)->refcnt++;
+   } else {
+      struct virgl_winsys *vws;
+
+      vws = virgl_drm_winsys_create(fd);
+      if (!vws) {
+         CloseHandle(fd);
+         goto unlock;
+      }
+
+      pscreen = virgl_create_screen(vws, config);
+      if (pscreen) {
+         _mesa_hash_table_insert(fd_tab, fd, pscreen);
+
+         /* Bit of a hack, to avoid circular linkage dependency,
+          * ie. pipe driver having to call in to winsys, we
+          * override the pipe drivers screen->destroy():
+          */
+         virgl_screen(pscreen)->winsys_priv = pscreen->destroy;
+         pscreen->destroy = virgl_drm_screen_destroy;
+      }
+   }
+
+unlock:
+   simple_mtx_unlock(&virgl_screen_mutex);
+
+   return pscreen;
+}
+#else
 struct pipe_screen *
 virgl_drm_screen_create(int fd, const struct pipe_screen_config *config)
 {
@@ -1385,3 +1785,4 @@ unlock:
    mtx_unlock(&virgl_screen_mutex);
    return pscreen;
 }
+#endif
diff --git a/src/gallium/winsys/virgl/drm/virgl_drm_winsys.h b/src/gallium/winsys/virgl/drm/virgl_drm_winsys.h
index f17d89c098b..fa1b6f9f957 100644
--- a/src/gallium/winsys/virgl/drm/virgl_drm_winsys.h
+++ b/src/gallium/winsys/virgl/drm/virgl_drm_winsys.h
@@ -91,7 +91,11 @@ struct param params[] = { PARAM(VIRTGPU_PARAM_3D_FEATURES),
 struct virgl_drm_winsys
 {
    struct virgl_winsys base;
+#ifdef _WIN32
+   HANDLE fd;
+#else
    int fd;
+#endif
    struct virgl_resource_cache cache;
    mtx_t mutex;
 
@@ -104,7 +108,11 @@ struct virgl_drm_winsys
 struct virgl_drm_fence {
    struct pipe_reference reference;
    bool external;
+#ifdef _WIN32
+   HANDLE fd;
+#else
    int fd;
+#endif
    struct virgl_hw_res *hw_res;
 };
 
@@ -113,7 +121,11 @@ struct virgl_drm_cmd_buf {
 
    uint32_t *buf;
 
+#ifdef _WIN32
+   HANDLE in_fence_fd;
+#else
    int in_fence_fd;
+#endif
 
    unsigned nres;
    unsigned cres;
diff --git a/src/gallium/winsys/virgl/lib/ioctl.h b/src/gallium/winsys/virgl/lib/ioctl.h
new file mode 100644
index 00000000000..4fa845df61b
--- /dev/null
+++ b/src/gallium/winsys/virgl/lib/ioctl.h
@@ -0,0 +1,87 @@
+/*
+ * MVisor vgpu Device guest driver
+ * Copyright (C) 2022 cair <rui.cai@tenclass.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+#ifndef IOCTL_H
+#define IOCTL_H
+
+#include <winioctl.h>
+#include <initguid.h>
+
+// 31c22912-7210-11ed-bf22-bce92fa2e22d
+DEFINE_GUID(GUID_DEVINTERFACE_VGPU, 0x31c22912, 0x7210, 0x11ed, 0xbf, 0x22, 0xbc, 0xe9, 0x2f, 0xa2, 0xe2, 0x2d);
+
+#define IOCTL_VIRTIO_VGPU_CONTEXT_INIT CTL_CODE(FILE_DEVICE_UNKNOWN, \
+    0x800, \
+    METHOD_OUT_DIRECT, \
+    FILE_ANY_ACCESS)
+
+#define IOCTL_VIRTIO_VGPU_DESTROY_CONTEXT CTL_CODE(FILE_DEVICE_UNKNOWN, \
+    0x801, \
+    METHOD_IN_DIRECT, \
+    FILE_ANY_ACCESS)
+
+#define IOCTL_VIRTIO_VGPU_MAP CTL_CODE(FILE_DEVICE_UNKNOWN, \
+    0x802, \
+    METHOD_OUT_DIRECT, \
+    FILE_ANY_ACCESS)
+
+#define IOCTL_VIRTIO_VGPU_EXECBUFFER CTL_CODE(FILE_DEVICE_UNKNOWN, \
+    0x803, \
+    METHOD_IN_DIRECT, \
+    FILE_ANY_ACCESS)
+
+#define IOCTL_VIRTIO_VGPU_GETPARAM CTL_CODE(FILE_DEVICE_UNKNOWN, \
+    0x804, \
+    METHOD_OUT_DIRECT, \
+    FILE_ANY_ACCESS)
+
+#define IOCTL_VIRTIO_VGPU_GET_CAPS CTL_CODE(FILE_DEVICE_UNKNOWN, \
+    0x805, \
+    METHOD_OUT_DIRECT, \
+    FILE_ANY_ACCESS)
+
+#define IOCTL_VIRTIO_VGPU_RESOURCE_CREATE CTL_CODE(FILE_DEVICE_UNKNOWN, \
+    0x806, \
+    METHOD_OUT_DIRECT, \
+    FILE_ANY_ACCESS)
+
+#define IOCTL_VIRTIO_VGPU_RESOURCE_CLOSE CTL_CODE(FILE_DEVICE_UNKNOWN, \
+    0x807, \
+    METHOD_IN_DIRECT, \
+    FILE_ANY_ACCESS)
+
+#define IOCTL_VIRTIO_VGPU_TRANSFER_FROM_HOST CTL_CODE(FILE_DEVICE_UNKNOWN, \
+    0x808, \
+    METHOD_IN_DIRECT, \
+    FILE_ANY_ACCESS)
+
+#define IOCTL_VIRTIO_VGPU_TRANSFER_TO_HOST CTL_CODE(FILE_DEVICE_UNKNOWN, \
+    0x809, \
+    METHOD_IN_DIRECT, \
+    FILE_ANY_ACCESS)
+
+#define IOCTL_VIRTIO_VGPU_WAIT CTL_CODE(FILE_DEVICE_UNKNOWN, \
+    0x810, \
+    METHOD_OUT_DIRECT, \
+    FILE_ANY_ACCESS)
+
+#define IOCTL_VIRTIO_VGPU_BLOB_RESOURCE_CREATE CTL_CODE(FILE_DEVICE_UNKNOWN, \
+    0x811, \
+    METHOD_OUT_DIRECT, \
+    FILE_ANY_ACCESS)
+
+#endif
diff --git a/src/gallium/winsys/virgl/lib/meson.build b/src/gallium/winsys/virgl/lib/meson.build
new file mode 100644
index 00000000000..6576e0616ef
--- /dev/null
+++ b/src/gallium/winsys/virgl/lib/meson.build
@@ -0,0 +1,34 @@
+# MVisor vgpu Device guest driver
+# Copyright (C) 2022 cair <rui.cai@tenclass.com>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <https://www.gnu.org/licenses/>.
+
+deps = []
+if host_machine.system() == 'windows'
+  c = meson.get_compiler('c')
+  deps += c.find_library('Setupapi')
+endif
+
+libvgpuapi = static_library(
+  'vgpu_api',
+  'vgpu_api.c',
+  include_directories : [inc_include, inc_src, inc_mapi, inc_mesa, inc_gallium, inc_gallium_aux, inc_gallium_drivers, inc_virtio],
+  dependencies : [dep_libdrm, idep_mesautil, idep_nir_headers, deps],
+  gnu_symbol_visibility : 'hidden',
+)
+
+dep_libvgpuapi = declare_dependency(
+  link_with : libvgpuapi,
+  include_directories : include_directories('.'),
+)
diff --git a/src/gallium/winsys/virgl/lib/vgpu_api.c b/src/gallium/winsys/virgl/lib/vgpu_api.c
new file mode 100644
index 00000000000..c0437792c5f
--- /dev/null
+++ b/src/gallium/winsys/virgl/lib/vgpu_api.c
@@ -0,0 +1,319 @@
+/*
+ * MVisor vgpu Device guest driver
+ * Copyright (C) 2022 cair <rui.cai@tenclass.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+
+#include <windows.h>
+#include <stdio.h>
+#include <setupapi.h>
+#include <cfgmgr32.h>
+#include <shlwapi.h>
+
+#include "vgpu_api.h"
+#include "ioctl.h"
+#include "util/u_debug.h"
+
+#include "drm-uapi/virtgpu_drm.h"
+
+int drmPrimeHandleToFD(int fd, UINT32 handle, UINT32 flags, int *prime_fd)
+{
+    _debug_printf("drmPrimeHandleToFD not implement\n");
+    return 0;
+}
+
+int drmPrimeFDToHandle(int fd, int prime_fd, UINT32 *handle)
+{
+    _debug_printf("drmPrimeFDToHandle not implement\n");
+    return 0;
+}
+
+drmVersionPtr drmGetVersion(HANDLE fd)
+{
+    drmVersionPtr version = (drmVersionPtr)malloc(sizeof(drmVersion));
+    if (version)
+    {
+        version->version_major = 0;
+        version->version_minor = 1;
+        return version;
+    }
+
+    return NULL;
+}
+
+void drmFreeVersion(drmVersionPtr ptr)
+{
+    if (ptr)
+    {
+        free(ptr);
+    }
+}
+
+HANDLE GetHandleFromVgpu(void)
+{
+    BOOL bRet = FALSE;
+    HANDLE handle = INVALID_HANDLE_VALUE;
+    HDEVINFO HardwareDeviceInfo = NULL;
+    DWORD RequiredLength = 0;
+    PSP_DEVICE_INTERFACE_DETAIL_DATA DeviceInterfaceDetailData = NULL;
+    SP_DEVINFO_DATA DevInfoData = {sizeof(SP_DEVINFO_DATA)};
+    SP_DEVICE_INTERFACE_DATA DeviceInterfaceData;
+
+    HardwareDeviceInfo = SetupDiGetClassDevs(
+        &GUID_DEVINTERFACE_VGPU,
+        NULL,
+        NULL,
+        (DIGCF_PRESENT | DIGCF_DEVICEINTERFACE));
+
+    if (HardwareDeviceInfo == INVALID_HANDLE_VALUE)
+    {
+        _debug_printf("Cannot get class devices.\n");
+        return NULL;
+    }
+
+    DeviceInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
+    bRet = SetupDiEnumDeviceInterfaces(HardwareDeviceInfo, NULL, &GUID_DEVINTERFACE_VGPU, 0, &DeviceInterfaceData);
+    if (!bRet)
+    {
+        _debug_printf("SetupDiEnumDeviceInterfaces failed err=%d.\n", GetLastError());
+        return NULL;
+    }
+
+    SetupDiGetDeviceInterfaceDetail(HardwareDeviceInfo, &DeviceInterfaceData, NULL, 0, &RequiredLength, NULL);
+    assert(RequiredLength > 0);
+
+    DeviceInterfaceDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA)malloc(RequiredLength);
+    if (DeviceInterfaceDetailData == NULL)
+    {
+        _debug_printf("Cannot allocate memory.\n");
+        return NULL;
+    }
+
+    DeviceInterfaceDetailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
+    bRet = SetupDiGetDeviceInterfaceDetail(
+        HardwareDeviceInfo,
+        &DeviceInterfaceData,
+        DeviceInterfaceDetailData,
+        RequiredLength,
+        NULL,
+        &DevInfoData);
+    if (!bRet)
+    {
+        _debug_printf("SetupDiGetDeviceInterfaceDetail failed err=%d.\n", GetLastError());
+        return NULL;
+    }
+
+    handle = CreateFile(DeviceInterfaceDetailData->DevicePath, GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
+    if (handle == INVALID_HANDLE_VALUE)
+    {
+        _debug_printf("CreateFile failed err=%d.\n", GetLastError());
+        assert(0);
+    }
+
+    free((PVOID)DeviceInterfaceDetailData);
+    SetupDiDestroyDeviceInfoList(HardwareDeviceInfo);
+    return handle;
+}
+
+static int ctl_get_param(HANDLE handle, struct drm_virtgpu_getparam *getparam)
+{
+    DWORD BytesReturned;
+    BOOL ret = DeviceIoControl(handle, IOCTL_VIRTIO_VGPU_GETPARAM, &getparam->param, sizeof(uint64_t),
+                               (void *)getparam->value, sizeof(uint64_t), &BytesReturned, NULL);
+    if (!ret)
+    {
+        _debug_printf("IOCTL_VIRTIO_VGPU_GETPARAM failed=%d\n", GetLastError());
+        return -1;
+    }
+
+    return 0;
+}
+
+static int ctl_get_caps(HANDLE handle, struct drm_virtgpu_get_caps *getcaps)
+{
+    DWORD BytesReturned;
+    BOOL ret = DeviceIoControl(handle, IOCTL_VIRTIO_VGPU_GET_CAPS, &getcaps->cap_set_id, sizeof(uint32_t) * 2,
+                               (void *)getcaps->addr, getcaps->size, &BytesReturned, NULL);
+    if (!ret)
+    {
+        _debug_printf("IOCTL_VIRTIO_VGPU_GET_CAPS failed=%d\n", GetLastError());
+        return -1;
+    }
+
+    return 0;
+}
+
+static int ctl_create_resource(HANDLE handle, struct drm_virtgpu_resource_create *createcmd)
+{
+    DWORD BytesReturned;
+    BOOL ret = DeviceIoControl(handle, IOCTL_VIRTIO_VGPU_RESOURCE_CREATE, createcmd, sizeof(*createcmd),
+                               (void *)&createcmd->bo_handle, sizeof(uint32_t) * 2, &BytesReturned, NULL);
+    if (!ret)
+    {
+        _debug_printf("IOCTL_VIRTIO_VGPU_RESOURCE_CREATE failed=%d\n", GetLastError());
+        return -1;
+    }
+
+    return 0;
+}
+
+static int ctl_create_blob_resource(HANDLE handle, struct drm_virtgpu_resource_create_blob *createcmd)
+{
+    DWORD BytesReturned;
+    BOOL ret = DeviceIoControl(handle, IOCTL_VIRTIO_VGPU_BLOB_RESOURCE_CREATE, createcmd, sizeof(*createcmd),
+                               (void *)&createcmd->bo_handle, sizeof(uint32_t) * 2, &BytesReturned, NULL);
+    if (!ret)
+    {
+        _debug_printf("IOCTL_VIRTIO_VGPU_BLOB_RESOURCE_CREATE failed=%d\n", GetLastError());
+        return -1;
+    }
+
+    return 0;
+}
+
+static int ctl_submit_command(HANDLE handle, struct drm_virtgpu_execbuffer *eb)
+{
+    DWORD BytesReturned;
+    BOOL ret = DeviceIoControl(handle, IOCTL_VIRTIO_VGPU_EXECBUFFER, eb, sizeof(*eb), NULL, 0, &BytesReturned, NULL);
+    if (!ret)
+    {
+        _debug_printf("IOCTL_VIRTIO_VGPU_EXECBUFFER failed=%d\n", GetLastError());
+        return -1;
+    }
+
+    return 0;
+}
+
+static int ctl_close_resource(HANDLE handle, struct drm_gem_close *close)
+{
+    DWORD BytesReturned;
+    BOOL ret = DeviceIoControl(handle, IOCTL_VIRTIO_VGPU_RESOURCE_CLOSE, close, sizeof(*close), NULL, 0, &BytesReturned, NULL);
+    if (!ret)
+    {
+        _debug_printf("IOCTL_VIRTIO_VGPU_RESOURCE_CLOSE failed=%d\n", GetLastError());
+        return -1;
+    }
+
+    return 0;
+}
+
+static int ctl_wait_resource(HANDLE handle, struct drm_virtgpu_3d_wait *wait)
+{
+    DWORD BytesReturned;
+    ULONG32 result;
+    BOOL ret = DeviceIoControl(handle, IOCTL_VIRTIO_VGPU_WAIT, wait, sizeof(*wait), &result, sizeof(ULONG32), &BytesReturned, NULL);
+    if (!ret)
+    {
+        _debug_printf("IOCTL_VIRTIO_VGPU_WAIT failed=%d\n", GetLastError());
+        return -1;
+    }
+
+    return result;
+}
+
+static int ctl_map_resource(HANDLE handle, struct drm_virtgpu_map *map)
+{
+    DWORD BytesReturned;
+    BOOL ret = DeviceIoControl(handle, IOCTL_VIRTIO_VGPU_MAP, map, sizeof(*map), &map->offset, sizeof(ULONG64), &BytesReturned, NULL);
+    if (!ret)
+    {
+        _debug_printf("IOCTL_VIRTIO_VGPU_MAP failed=%d\n", GetLastError());
+        return -1;
+    }
+
+    return 0;
+}
+
+static int ctl_transfer_to_host(HANDLE handle, struct drm_virtgpu_3d_transfer *transfer)
+{
+    DWORD BytesReturned;
+    BOOL ret = DeviceIoControl(handle, IOCTL_VIRTIO_VGPU_TRANSFER_TO_HOST, transfer, sizeof(*transfer), NULL, 0, &BytesReturned, NULL);
+    if (!ret)
+    {
+        _debug_printf("IOCTL_VIRTIO_VGPU_TRANSFER_TO_HOST failed=%d\n", GetLastError());
+        return -1;
+    }
+
+    return 0;
+}
+
+static int ctl_transfer_from_host(HANDLE handle, struct drm_virtgpu_3d_transfer *transfer)
+{
+    DWORD BytesReturned;
+    BOOL ret = DeviceIoControl(handle, IOCTL_VIRTIO_VGPU_TRANSFER_FROM_HOST, transfer, sizeof(*transfer), NULL, 0, &BytesReturned, NULL);
+    if (!ret)
+    {
+        _debug_printf("IOCTL_VIRTIO_VGPU_TRANSFER_FROM_HOST failed=%d\n", GetLastError());
+        return -1;
+    }
+
+    return 0;
+}
+
+static int ctl_context_init(HANDLE handle, struct drm_virtgpu_context_init *init)
+{
+    DWORD BytesReturned;
+    BOOL ret = DeviceIoControl(handle, IOCTL_VIRTIO_VGPU_CONTEXT_INIT, init, sizeof(*init), NULL, 0, &BytesReturned, NULL);
+    if (!ret)
+    {
+        _debug_printf("IOCTL_VIRTIO_VGPU_CONTEXT_INIT failed=%d\n", GetLastError());
+        return -1;
+    }
+
+    return 0;
+}
+
+void DestroyVirglContext(HANDLE handle)
+{
+    bool ret = DeviceIoControl(handle, IOCTL_VIRTIO_VGPU_DESTROY_CONTEXT, NULL, 0, NULL, 0, NULL, NULL);
+    if (!ret)
+    {
+        _debug_printf("IOCTL_VIRTIO_VGPU_DESTROY_CONTEXT failed=%d\n", GetLastError());
+    }
+}
+
+int drmIoctl(HANDLE handle, unsigned long request, void *arg)
+{
+    switch (request)
+    {
+    case DRM_IOCTL_VIRTGPU_CONTEXT_INIT:
+        return ctl_context_init(handle, arg);
+    case DRM_IOCTL_VIRTGPU_GETPARAM:
+        return ctl_get_param(handle, arg);
+    case DRM_IOCTL_VIRTGPU_GET_CAPS:
+        return ctl_get_caps(handle, arg);
+    case DRM_IOCTL_VIRTGPU_RESOURCE_CREATE:
+        return ctl_create_resource(handle, arg);
+    case DRM_IOCTL_VIRTGPU_RESOURCE_CREATE_BLOB:
+        return ctl_create_blob_resource(handle, arg);
+    case DRM_IOCTL_VIRTGPU_EXECBUFFER:
+        return ctl_submit_command(handle, arg);
+    case DRM_IOCTL_GEM_CLOSE:
+        return ctl_close_resource(handle, arg);
+    case DRM_IOCTL_VIRTGPU_WAIT:
+        return ctl_wait_resource(handle, arg);
+    case DRM_IOCTL_VIRTGPU_MAP:
+        return ctl_map_resource(handle, arg);
+    case DRM_IOCTL_VIRTGPU_TRANSFER_FROM_HOST:
+        return ctl_transfer_from_host(handle, arg);
+    case DRM_IOCTL_VIRTGPU_TRANSFER_TO_HOST:
+        return ctl_transfer_to_host(handle, arg);
+    default:
+        _debug_printf("drmIoctl not implement handle=0x%lx request=0x%x\n", handle, request);
+        return -1;
+    }
+
+    return 0;
+}
diff --git a/src/gallium/winsys/virgl/lib/vgpu_api.h b/src/gallium/winsys/virgl/lib/vgpu_api.h
new file mode 100644
index 00000000000..aa1d51c2bec
--- /dev/null
+++ b/src/gallium/winsys/virgl/lib/vgpu_api.h
@@ -0,0 +1,47 @@
+/*
+ * MVisor vgpu Device guest driver
+ * Copyright (C) 2022 cair <rui.cai@tenclass.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+#ifndef VGPU_API_H
+#define VGPU_API_H
+
+/**
+ * Driver version information.
+ *
+ * \sa drmGetVersion() and drmSetVersion().
+ */
+typedef struct _drmVersion
+{
+    int version_major;      /**< Major version */
+    int version_minor;      /**< Minor version */
+    int version_patchlevel; /**< Patch level */
+    int name_len;           /**< Length of name buffer */
+    char *name;             /**< Name of driver */
+    int date_len;           /**< Length of date buffer */
+    char *date;             /**< User-space buffer to hold date */
+    int desc_len;           /**< Length of desc buffer */
+    char *desc;             /**< User-space buffer to hold desc */
+} drmVersion, *drmVersionPtr;
+
+int drmIoctl(HANDLE fd, unsigned long request, void *arg);
+int drmPrimeHandleToFD(int fd, UINT32 handle, UINT32 flags, int *prime_fd);
+int drmPrimeFDToHandle(int fd, int prime_fd, UINT32 *handle);
+drmVersionPtr drmGetVersion(HANDLE fd);
+void drmFreeVersion(drmVersionPtr ptr);
+HANDLE GetHandleFromVgpu(void);
+void DestroyVirglContext(HANDLE handle);
+
+#endif
diff --git a/src/mesa/main/version.c b/src/mesa/main/version.c
index 2f36a44ddee..2bccb107c10 100644
--- a/src/mesa/main/version.c
+++ b/src/mesa/main/version.c
@@ -133,7 +133,7 @@ create_version_string(struct gl_context *ctx, const char *prefix)
    ctx->VersionString = malloc(max);
    if (ctx->VersionString) {
       snprintf(ctx->VersionString, max,
-		     "%s%u.%u%s Mesa " PACKAGE_VERSION MESA_GIT_SHA1,
+		     "%s%u.%u%s Mvisor Usermode Driver ",
 		     prefix,
 		     ctx->Version / 10, ctx->Version % 10,
 		     _mesa_is_desktop_gl_core(ctx) ? " (Core Profile)" :
-- 
2.29.2.windows.2

