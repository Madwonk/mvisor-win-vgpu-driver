From 70b5f7a00edca88c9076ca6523187a749f1a45cc Mon Sep 17 00:00:00 2001
From: cair <rui.cai@tenclass.com>
Date: Mon, 6 Feb 2023 22:18:22 +0800
Subject: [PATCH] virgl icd for windows

---
 include/drm-uapi/drm.h                        |   4 +
 include/drm-uapi/virtgpu_drm.h                |   9 +
 include/linuz/ioccom.h                        |  91 ++
 include/linuz/xf86drm.h                       | 899 ++++++++++++++++++
 src/c11/threads.h                             |   2 +
 src/gallium/drivers/virgl/meson.build         |   2 +-
 src/gallium/drivers/virgl/virgl_context.c     |   2 +
 src/gallium/drivers/virgl/virgl_screen.c      |   7 +-
 src/gallium/drivers/virgl/virgl_video.c       |   2 +-
 src/gallium/drivers/virgl/virgl_winsys.h      |   8 +-
 src/gallium/meson.build                       |   2 +-
 src/gallium/targets/wgl/meson.build           |   2 +-
 src/gallium/targets/wgl/wgl.c                 |  43 +-
 src/gallium/winsys/virgl/drm/meson.build      |   2 +-
 .../winsys/virgl/drm/virgl_drm_public.h       |   2 +-
 .../winsys/virgl/drm/virgl_drm_winsys.c       | 160 +++-
 .../winsys/virgl/drm/virgl_drm_winsys.h       |   4 +-
 src/gallium/winsys/virgl/lib/ioctl.h          |  82 ++
 src/gallium/winsys/virgl/lib/meson.build      |  34 +
 src/gallium/winsys/virgl/lib/vgpu_api.c       | 300 ++++++
 src/gallium/winsys/virgl/lib/vgpu_api.h       |  47 +
 src/util/mesa_cache_db.h                      |   7 +-
 22 files changed, 1675 insertions(+), 36 deletions(-)
 create mode 100644 include/linuz/ioccom.h
 create mode 100644 include/linuz/xf86drm.h
 create mode 100644 src/gallium/winsys/virgl/lib/ioctl.h
 create mode 100644 src/gallium/winsys/virgl/lib/meson.build
 create mode 100644 src/gallium/winsys/virgl/lib/vgpu_api.c
 create mode 100644 src/gallium/winsys/virgl/lib/vgpu_api.h

diff --git a/include/drm-uapi/drm.h b/include/drm-uapi/drm.h
index c76325fc3cb..7bbd41ba9e8 100644
--- a/include/drm-uapi/drm.h
+++ b/include/drm-uapi/drm.h
@@ -44,7 +44,11 @@ typedef unsigned int drm_handle_t;
 #else /* One of the BSDs */
 
 #include <stdint.h>
+#ifdef _WIN32
+#include "linuz/ioccom.h"
+#else
 #include <sys/ioccom.h>
+#endif
 #include <sys/types.h>
 typedef int8_t   __s8;
 typedef uint8_t  __u8;
diff --git a/include/drm-uapi/virtgpu_drm.h b/include/drm-uapi/virtgpu_drm.h
index 0512fde5e69..d3b709fba7c 100644
--- a/include/drm-uapi/virtgpu_drm.h
+++ b/include/drm-uapi/virtgpu_drm.h
@@ -123,6 +123,15 @@ struct drm_virtgpu_3d_box {
 	__u32 d;
 };
 
+struct drm_virtgpu_3d_transfer {
+    __u32 bo_handle;
+    struct drm_virtgpu_3d_box box;
+    __u32 level;
+    __u32 offset;
+    __u32 stride;
+    __u32 layer_stride;
+};
+
 struct drm_virtgpu_3d_transfer_to_host {
 	__u32 bo_handle;
 	struct drm_virtgpu_3d_box box;
diff --git a/include/linuz/ioccom.h b/include/linuz/ioccom.h
new file mode 100644
index 00000000000..00e87d9aa3a
--- /dev/null
+++ b/include/linuz/ioccom.h
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
+ *
+ * @APPLE_LICENSE_HEADER_START@
+ *
+ * The contents of this file constitute Original Code as defined in and
+ * are subject to the Apple Public Source License Version 1.1 (the
+ * "License").  You may not use this file except in compliance with the
+ * License.  Please obtain a copy of the License at
+ * http://www.apple.com/publicsource and read it before using this file.
+ * 
+ * This Original Code and all software distributed under the License are
+ * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
+ * License for the specific language governing rights and limitations
+ * under the License.
+ * 
+ * @APPLE_LICENSE_HEADER_END@
+ */
+/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
+/*-
+ * Copyright (c) 1982, 1986, 1990, 1993, 1994
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)ioccom.h	8.2 (Berkeley) 3/28/94
+ */
+
+#ifndef	_SYS_IOCCOM_H_
+#define	_SYS_IOCCOM_H_
+
+/*
+ * Ioctl's have the command encoded in the lower word, and the size of
+ * any in or out parameters in the upper word.  The high 3 bits of the
+ * upper word are used to encode the in/out status of the parameter.
+ */
+#define	IOCPARM_MASK	0x1fff		/* parameter length, at most 13 bits */
+#define	IOCPARM_LEN(x)	(((x) >> 16) & IOCPARM_MASK)
+#define	IOCBASECMD(x)	((x) & ~(IOCPARM_MASK << 16))
+#define	IOCGROUP(x)	(((x) >> 8) & 0xff)
+
+#define	IOCPARM_MAX	(IOCPARM_MASK + 1)	/* max size of ioctl args */
+				/* no parameters */
+#define	IOC_VOID	(unsigned long)0x20000000
+				/* copy parameters out */
+#define	IOC_OUT		(unsigned long)0x40000000
+				/* copy parameters in */
+#define	IOC_IN		(unsigned long)0x80000000
+				/* copy paramters in and out */
+#define	IOC_INOUT	(IOC_IN|IOC_OUT)
+				/* mask for IN/OUT/VOID */
+#define	IOC_DIRMASK	(unsigned long)0xe0000000
+
+#define	_IOC(inout,group,num,len) \
+	(inout | ((len & IOCPARM_MASK) << 16) | ((group) << 8) | (num))
+#define	_IO(g,n)	_IOC(IOC_VOID,	(g), (n), 0)
+#define	_IOR(g,n,t)	_IOC(IOC_OUT,	(g), (n), sizeof(t))
+#define	_IOW(g,n,t)	_IOC(IOC_IN,	(g), (n), sizeof(t))
+/* this should be _IORW, but stdio got there first */
+#define	_IOWR(g,n,t)	_IOC(IOC_INOUT,	(g), (n), sizeof(t))
+
+#endif /* !_SYS_IOCCOM_H_ */
diff --git a/include/linuz/xf86drm.h b/include/linuz/xf86drm.h
new file mode 100644
index 00000000000..be8a0bad908
--- /dev/null
+++ b/include/linuz/xf86drm.h
@@ -0,0 +1,899 @@
+/**
+ * \file xf86drm.h 
+ * OS-independent header for DRM user-level library interface.
+ *
+ * \author Rickard E. (Rik) Faith <faith@valinux.com>
+ */
+ 
+/*
+ * Copyright 1999, 2000 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _XF86DRM_H_
+#define _XF86DRM_H_
+
+#include <stdarg.h>
+#include <sys/types.h>
+#include <stdint.h>
+#include <drm.h>
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+#ifndef DRM_MAX_MINOR
+#define DRM_MAX_MINOR   16
+#endif
+
+#if defined(__linux__)
+
+#define DRM_IOCTL_NR(n)		_IOC_NR(n)
+#define DRM_IOC_VOID		_IOC_NONE
+#define DRM_IOC_READ		_IOC_READ
+#define DRM_IOC_WRITE		_IOC_WRITE
+#define DRM_IOC_READWRITE	_IOC_READ|_IOC_WRITE
+#define DRM_IOC(dir, group, nr, size) _IOC(dir, group, nr, size)
+
+#else /* One of the *BSDs */
+
+#if (defined(__QNX__) || defined(__QNXNTO__)) /* NVIDIA - It's 'sys/ioctl.h' on QNX7 */
+#include <sys/ioctl.h>
+#else
+#include <sys/ioccom.h>
+#endif
+#define DRM_IOCTL_NR(n)         ((n) & 0xff)
+#define DRM_IOC_VOID            IOC_VOID
+#define DRM_IOC_READ            IOC_OUT
+#define DRM_IOC_WRITE           IOC_IN
+#define DRM_IOC_READWRITE       IOC_INOUT
+#define DRM_IOC(dir, group, nr, size) _IOC(dir, group, nr, size)
+
+#endif
+
+				/* Defaults, if nothing set in xf86config */
+#define DRM_DEV_UID	 0
+#define DRM_DEV_GID	 0
+/* Default /dev/dri directory permissions 0755 */
+#define DRM_DEV_DIRMODE	 	\
+	(S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH)
+#define DRM_DEV_MODE	 (S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP)
+
+#ifdef __OpenBSD__
+#define DRM_DIR_NAME  "/dev"
+#define DRM_DEV_NAME  "%s/drm%d"
+#define DRM_CONTROL_DEV_NAME  "%s/drmC%d"
+#define DRM_RENDER_DEV_NAME  "%s/drmR%d"
+#else
+#define DRM_DIR_NAME  "/dev/dri"
+#define DRM_DEV_NAME  "%s/card%d"
+#define DRM_CONTROL_DEV_NAME  "%s/controlD%d"
+#define DRM_RENDER_DEV_NAME  "%s/renderD%d"
+#define DRM_PROC_NAME "/proc/dri/" /* For backward Linux compatibility */
+#endif
+
+#define DRM_ERR_NO_DEVICE  (-1001)
+#define DRM_ERR_NO_ACCESS  (-1002)
+#define DRM_ERR_NOT_ROOT   (-1003)
+#define DRM_ERR_INVALID    (-1004)
+#define DRM_ERR_NO_FD      (-1005)
+
+#define DRM_AGP_NO_HANDLE 0
+
+typedef unsigned int  drmSize,     *drmSizePtr;	    /**< For mapped regions */
+typedef void          *drmAddress, **drmAddressPtr; /**< For mapped regions */
+
+#if (__GNUC__ >= 3)
+#define DRM_PRINTFLIKE(f, a) __attribute__ ((format(__printf__, f, a)))
+#else
+#define DRM_PRINTFLIKE(f, a)
+#endif
+
+typedef struct _drmServerInfo {
+  int (*debug_print)(const char *format, va_list ap) DRM_PRINTFLIKE(1,0);
+  int (*load_module)(const char *name);
+  void (*get_perms)(gid_t *, mode_t *);
+} drmServerInfo, *drmServerInfoPtr;
+
+typedef struct drmHashEntry {
+    int      fd;
+    void     (*f)(int, void *, void *);
+    void     *tagTable;
+} drmHashEntry;
+
+extern int drmIoctl(int fd, unsigned long request, void *arg);
+extern void *drmGetHashTable(void);
+extern drmHashEntry *drmGetEntry(int fd);
+
+/**
+ * Driver version information.
+ *
+ * \sa drmGetVersion() and drmSetVersion().
+ */
+typedef struct _drmVersion {
+    int     version_major;        /**< Major version */
+    int     version_minor;        /**< Minor version */
+    int     version_patchlevel;   /**< Patch level */
+    int     name_len; 	          /**< Length of name buffer */
+    char    *name;	          /**< Name of driver */
+    int     date_len;             /**< Length of date buffer */
+    char    *date;                /**< User-space buffer to hold date */
+    int     desc_len;	          /**< Length of desc buffer */
+    char    *desc;                /**< User-space buffer to hold desc */
+} drmVersion, *drmVersionPtr;
+
+typedef struct _drmStats {
+    unsigned long count;	     /**< Number of data */
+    struct {
+	unsigned long value;	     /**< Value from kernel */
+	const char    *long_format;  /**< Suggested format for long_name */
+	const char    *long_name;    /**< Long name for value */
+	const char    *rate_format;  /**< Suggested format for rate_name */
+	const char    *rate_name;    /**< Short name for value per second */
+	int           isvalue;       /**< True if value (vs. counter) */
+	const char    *mult_names;   /**< Multiplier names (e.g., "KGM") */
+	int           mult;          /**< Multiplier value (e.g., 1024) */
+	int           verbose;       /**< Suggest only in verbose output */
+    } data[15];
+} drmStatsT;
+
+
+				/* All of these enums *MUST* match with the
+                                   kernel implementation -- so do *NOT*
+                                   change them!  (The drmlib implementation
+                                   will just copy the flags instead of
+                                   translating them.) */
+typedef enum {
+    DRM_FRAME_BUFFER    = 0,      /**< WC, no caching, no core dump */
+    DRM_REGISTERS       = 1,      /**< no caching, no core dump */
+    DRM_SHM             = 2,      /**< shared, cached */
+    DRM_AGP             = 3,	  /**< AGP/GART */
+    DRM_SCATTER_GATHER  = 4,	  /**< PCI scatter/gather */
+    DRM_CONSISTENT      = 5	  /**< PCI consistent */
+} drmMapType;
+
+typedef enum {
+    DRM_RESTRICTED      = 0x0001, /**< Cannot be mapped to client-virtual */
+    DRM_READ_ONLY       = 0x0002, /**< Read-only in client-virtual */
+    DRM_LOCKED          = 0x0004, /**< Physical pages locked */
+    DRM_KERNEL          = 0x0008, /**< Kernel requires access */
+    DRM_WRITE_COMBINING = 0x0010, /**< Use write-combining, if available */
+    DRM_CONTAINS_LOCK   = 0x0020, /**< SHM page that contains lock */
+    DRM_REMOVABLE	= 0x0040  /**< Removable mapping */
+} drmMapFlags;
+
+/**
+ * \warning These values *MUST* match drm.h
+ */
+typedef enum {
+    /** \name Flags for DMA buffer dispatch */
+    /*@{*/
+    DRM_DMA_BLOCK        = 0x01, /**< 
+				  * Block until buffer dispatched.
+				  * 
+				  * \note the buffer may not yet have been
+				  * processed by the hardware -- getting a
+				  * hardware lock with the hardware quiescent
+				  * will ensure that the buffer has been
+				  * processed.
+				  */
+    DRM_DMA_WHILE_LOCKED = 0x02, /**< Dispatch while lock held */
+    DRM_DMA_PRIORITY     = 0x04, /**< High priority dispatch */
+    /*@}*/
+
+    /** \name Flags for DMA buffer request */
+    /*@{*/
+    DRM_DMA_WAIT         = 0x10, /**< Wait for free buffers */
+    DRM_DMA_SMALLER_OK   = 0x20, /**< Smaller-than-requested buffers OK */
+    DRM_DMA_LARGER_OK    = 0x40  /**< Larger-than-requested buffers OK */
+    /*@}*/
+} drmDMAFlags;
+
+typedef enum {
+    DRM_PAGE_ALIGN       = 0x01,
+    DRM_AGP_BUFFER       = 0x02,
+    DRM_SG_BUFFER        = 0x04,
+    DRM_FB_BUFFER        = 0x08,
+    DRM_PCI_BUFFER_RO    = 0x10
+} drmBufDescFlags;
+
+typedef enum {
+    DRM_LOCK_READY      = 0x01, /**< Wait until hardware is ready for DMA */
+    DRM_LOCK_QUIESCENT  = 0x02, /**< Wait until hardware quiescent */
+    DRM_LOCK_FLUSH      = 0x04, /**< Flush this context's DMA queue first */
+    DRM_LOCK_FLUSH_ALL  = 0x08, /**< Flush all DMA queues first */
+				/* These *HALT* flags aren't supported yet
+                                   -- they will be used to support the
+                                   full-screen DGA-like mode. */
+    DRM_HALT_ALL_QUEUES = 0x10, /**< Halt all current and future queues */
+    DRM_HALT_CUR_QUEUES = 0x20  /**< Halt all current queues */
+} drmLockFlags;
+
+typedef enum {
+    DRM_CONTEXT_PRESERVED = 0x01, /**< This context is preserved and
+				     never swapped. */
+    DRM_CONTEXT_2DONLY    = 0x02  /**< This context is for 2D rendering only. */
+} drm_context_tFlags, *drm_context_tFlagsPtr;
+
+typedef struct _drmBufDesc {
+    int              count;	  /**< Number of buffers of this size */
+    int              size;	  /**< Size in bytes */
+    int              low_mark;	  /**< Low water mark */
+    int              high_mark;	  /**< High water mark */
+} drmBufDesc, *drmBufDescPtr;
+
+typedef struct _drmBufInfo {
+    int              count;	  /**< Number of buffers described in list */
+    drmBufDescPtr    list;	  /**< List of buffer descriptions */
+} drmBufInfo, *drmBufInfoPtr;
+
+typedef struct _drmBuf {
+    int              idx;	  /**< Index into the master buffer list */
+    int              total;	  /**< Buffer size */
+    int              used;	  /**< Amount of buffer in use (for DMA) */
+    drmAddress       address;	  /**< Address */
+} drmBuf, *drmBufPtr;
+
+/**
+ * Buffer mapping information.
+ *
+ * Used by drmMapBufs() and drmUnmapBufs() to store information about the
+ * mapped buffers.
+ */
+typedef struct _drmBufMap {
+    int              count;	  /**< Number of buffers mapped */
+    drmBufPtr        list;	  /**< Buffers */
+} drmBufMap, *drmBufMapPtr;
+
+typedef struct _drmLock {
+    volatile unsigned int lock;
+    char                      padding[60];
+    /* This is big enough for most current (and future?) architectures:
+       DEC Alpha:              32 bytes
+       Intel Merced:           ?
+       Intel P5/PPro/PII/PIII: 32 bytes
+       Intel StrongARM:        32 bytes
+       Intel i386/i486:        16 bytes
+       MIPS:                   32 bytes (?)
+       Motorola 68k:           16 bytes
+       Motorola PowerPC:       32 bytes
+       Sun SPARC:              32 bytes
+    */
+} drmLock, *drmLockPtr;
+
+/**
+ * Indices here refer to the offset into
+ * list in drmBufInfo
+ */
+typedef struct _drmDMAReq {
+    drm_context_t    context;  	  /**< Context handle */
+    int           send_count;     /**< Number of buffers to send */
+    int           *send_list;     /**< List of handles to buffers */
+    int           *send_sizes;    /**< Lengths of data to send, in bytes */
+    drmDMAFlags   flags;          /**< Flags */
+    int           request_count;  /**< Number of buffers requested */
+    int           request_size;	  /**< Desired size of buffers requested */
+    int           *request_list;  /**< Buffer information */
+    int           *request_sizes; /**< Minimum acceptable sizes */
+    int           granted_count;  /**< Number of buffers granted at this size */
+} drmDMAReq, *drmDMAReqPtr;
+
+typedef struct _drmRegion {
+    drm_handle_t     handle;
+    unsigned int  offset;
+    drmSize       size;
+    drmAddress    map;
+} drmRegion, *drmRegionPtr;
+
+typedef struct _drmTextureRegion {
+    unsigned char next;
+    unsigned char prev;
+    unsigned char in_use;
+    unsigned char padding;	/**< Explicitly pad this out */
+    unsigned int  age;
+} drmTextureRegion, *drmTextureRegionPtr;
+
+
+typedef enum {
+    DRM_VBLANK_ABSOLUTE = 0x0,	/**< Wait for specific vblank sequence number */
+    DRM_VBLANK_RELATIVE = 0x1,	/**< Wait for given number of vblanks */
+    /* bits 1-6 are reserved for high crtcs */
+    DRM_VBLANK_HIGH_CRTC_MASK = 0x0000003e,
+    DRM_VBLANK_EVENT = 0x4000000,	/**< Send event instead of blocking */
+    DRM_VBLANK_FLIP = 0x8000000,	/**< Scheduled buffer swap should flip */
+    DRM_VBLANK_NEXTONMISS = 0x10000000,	/**< If missed, wait for next vblank */
+    DRM_VBLANK_SECONDARY = 0x20000000,	/**< Secondary display controller */
+    DRM_VBLANK_SIGNAL   = 0x40000000	/* Send signal instead of blocking */
+} drmVBlankSeqType;
+#define DRM_VBLANK_HIGH_CRTC_SHIFT 1
+
+typedef struct _drmVBlankReq {
+	drmVBlankSeqType type;
+	unsigned int sequence;
+	unsigned long signal;
+} drmVBlankReq, *drmVBlankReqPtr;
+
+typedef struct _drmVBlankReply {
+	drmVBlankSeqType type;
+	unsigned int sequence;
+	long tval_sec;
+	long tval_usec;
+} drmVBlankReply, *drmVBlankReplyPtr;
+
+typedef union _drmVBlank {
+	drmVBlankReq request;
+	drmVBlankReply reply;
+} drmVBlank, *drmVBlankPtr;
+
+typedef struct _drmSetVersion {
+	int drm_di_major;
+	int drm_di_minor;
+	int drm_dd_major;
+	int drm_dd_minor;
+} drmSetVersion, *drmSetVersionPtr;
+
+#define __drm_dummy_lock(lock) (*(__volatile__ unsigned int *)lock)
+
+#define DRM_LOCK_HELD  0x80000000U /**< Hardware lock is held */
+#define DRM_LOCK_CONT  0x40000000U /**< Hardware lock is contended */
+
+#if defined(__GNUC__) && (__GNUC__ >= 2)
+# if defined(__i386) || defined(__AMD64__) || defined(__x86_64__) || defined(__amd64__)
+				/* Reflect changes here to drmP.h */
+#define DRM_CAS(lock,old,new,__ret)                                    \
+	do {                                                           \
+                int __dummy;	/* Can't mark eax as clobbered */      \
+		__asm__ __volatile__(                                  \
+			"lock ; cmpxchg %4,%1\n\t"                     \
+                        "setnz %0"                                     \
+			: "=d" (__ret),                                \
+   			  "=m" (__drm_dummy_lock(lock)),               \
+                          "=a" (__dummy)                               \
+			: "2" (old),                                   \
+			  "r" (new));                                  \
+	} while (0)
+
+#elif defined(__alpha__)
+
+#define	DRM_CAS(lock, old, new, ret)		\
+	do {					\
+		int tmp, old32;			\
+		__asm__ __volatile__(		\
+		"	addl	$31, %5, %3\n"	\
+		"1:	ldl_l	%0, %2\n"	\
+		"	cmpeq	%0, %3, %1\n"	\
+		"	beq	%1, 2f\n"	\
+		"	mov	%4, %0\n"	\
+		"	stl_c	%0, %2\n"	\
+		"	beq	%0, 3f\n"	\
+		"	mb\n"			\
+		"2:	cmpeq	%1, 0, %1\n"	\
+		".subsection 2\n"		\
+		"3:	br	1b\n"		\
+		".previous"			\
+		: "=&r"(tmp), "=&r"(ret),	\
+		  "=m"(__drm_dummy_lock(lock)),	\
+		  "=&r"(old32)			\
+		: "r"(new), "r"(old)		\
+		: "memory");			\
+	} while (0)
+
+#elif defined(__sparc__)
+
+#define DRM_CAS(lock,old,new,__ret)				\
+do {	register unsigned int __old __asm("o0");		\
+	register unsigned int __new __asm("o1");		\
+	register volatile unsigned int *__lock __asm("o2");	\
+	__old = old;						\
+	__new = new;						\
+	__lock = (volatile unsigned int *)lock;			\
+	__asm__ __volatile__(					\
+		/*"cas [%2], %3, %0"*/				\
+		".word 0xd3e29008\n\t"				\
+		/*"membar #StoreStore | #StoreLoad"*/		\
+		".word 0x8143e00a"				\
+		: "=&r" (__new)					\
+		: "0" (__new),					\
+		  "r" (__lock),					\
+		  "r" (__old)					\
+		: "memory");					\
+	__ret = (__new != __old);				\
+} while(0)
+
+#elif defined(__ia64__)
+
+#ifdef __INTEL_COMPILER
+/* this currently generates bad code (missing stop bits)... */
+#include <ia64intrin.h>
+
+#define DRM_CAS(lock,old,new,__ret)					      \
+	do {								      \
+		unsigned long __result, __old = (old) & 0xffffffff;		\
+		__mf();							      	\
+		__result = _InterlockedCompareExchange_acq(&__drm_dummy_lock(lock), (new), __old);\
+		__ret = (__result) != (__old);					\
+/*		__ret = (__sync_val_compare_and_swap(&__drm_dummy_lock(lock), \
+						     (old), (new))	      \
+			 != (old));					      */\
+	} while (0)
+
+#else
+#define DRM_CAS(lock,old,new,__ret)					  \
+	do {								  \
+		unsigned int __result, __old = (old);			  \
+		__asm__ __volatile__(					  \
+			"mf\n"						  \
+			"mov ar.ccv=%2\n"				  \
+			";;\n"						  \
+			"cmpxchg4.acq %0=%1,%3,ar.ccv"			  \
+			: "=r" (__result), "=m" (__drm_dummy_lock(lock))  \
+			: "r" ((unsigned long)__old), "r" (new)			  \
+			: "memory");					  \
+		__ret = (__result) != (__old);				  \
+	} while (0)
+
+#endif
+
+#elif defined(__powerpc__)
+
+#define DRM_CAS(lock,old,new,__ret)			\
+	do {						\
+		__asm__ __volatile__(			\
+			"sync;"				\
+			"0:    lwarx %0,0,%1;"		\
+			"      xor. %0,%3,%0;"		\
+			"      bne 1f;"			\
+			"      stwcx. %2,0,%1;"		\
+			"      bne- 0b;"		\
+			"1:    "			\
+			"sync;"				\
+		: "=&r"(__ret)				\
+		: "r"(lock), "r"(new), "r"(old)		\
+		: "cr0", "memory");			\
+	} while (0)
+
+#endif /* architecture */
+#endif /* __GNUC__ >= 2 */
+
+#ifndef DRM_CAS
+#define DRM_CAS(lock,old,new,ret) do { ret=1; } while (0) /* FAST LOCK FAILS */
+#endif
+
+#if defined(__alpha__)
+#define DRM_CAS_RESULT(_result)		long _result
+#elif defined(__powerpc__)
+#define DRM_CAS_RESULT(_result)		int _result
+#else
+#define DRM_CAS_RESULT(_result)		char _result
+#endif
+
+#define DRM_LIGHT_LOCK(fd,lock,context)                                \
+	do {                                                           \
+                DRM_CAS_RESULT(__ret);                                 \
+		DRM_CAS(lock,context,DRM_LOCK_HELD|context,__ret);     \
+                if (__ret) drmGetLock(fd,context,0);                   \
+        } while(0)
+
+				/* This one counts fast locks -- for
+                                   benchmarking only. */
+#define DRM_LIGHT_LOCK_COUNT(fd,lock,context,count)                    \
+	do {                                                           \
+                DRM_CAS_RESULT(__ret);                                 \
+		DRM_CAS(lock,context,DRM_LOCK_HELD|context,__ret);     \
+                if (__ret) drmGetLock(fd,context,0);                   \
+                else       ++count;                                    \
+        } while(0)
+
+#define DRM_LOCK(fd,lock,context,flags)                                \
+	do {                                                           \
+		if (flags) drmGetLock(fd,context,flags);               \
+		else       DRM_LIGHT_LOCK(fd,lock,context);            \
+	} while(0)
+
+#define DRM_UNLOCK(fd,lock,context)                                    \
+	do {                                                           \
+                DRM_CAS_RESULT(__ret);                                 \
+		DRM_CAS(lock,DRM_LOCK_HELD|context,context,__ret);     \
+                if (__ret) drmUnlock(fd,context);                      \
+        } while(0)
+
+				/* Simple spin locks */
+#define DRM_SPINLOCK(spin,val)                                         \
+	do {                                                           \
+            DRM_CAS_RESULT(__ret);                                     \
+	    do {                                                       \
+		DRM_CAS(spin,0,val,__ret);                             \
+		if (__ret) while ((spin)->lock);                       \
+	    } while (__ret);                                           \
+	} while(0)
+
+#define DRM_SPINLOCK_TAKE(spin,val)                                    \
+	do {                                                           \
+            DRM_CAS_RESULT(__ret);                                     \
+            int  cur;                                                  \
+	    do {                                                       \
+                cur = (*spin).lock;                                    \
+		DRM_CAS(spin,cur,val,__ret);                           \
+	    } while (__ret);                                           \
+	} while(0)
+
+#define DRM_SPINLOCK_COUNT(spin,val,count,__ret)                       \
+	do {                                                           \
+            int  __i;                                                  \
+            __ret = 1;                                                 \
+            for (__i = 0; __ret && __i < count; __i++) {               \
+		DRM_CAS(spin,0,val,__ret);                             \
+		if (__ret) for (;__i < count && (spin)->lock; __i++);  \
+	    }                                                          \
+	} while(0)
+
+#define DRM_SPINUNLOCK(spin,val)                                       \
+	do {                                                           \
+            DRM_CAS_RESULT(__ret);                                     \
+            if ((*spin).lock == val) { /* else server stole lock */    \
+	        do {                                                   \
+		    DRM_CAS(spin,val,0,__ret);                         \
+	        } while (__ret);                                       \
+            }                                                          \
+	} while(0)
+
+
+
+/* General user-level programmer's API: unprivileged */
+extern int           drmAvailable(void);
+extern int           drmOpen(const char *name, const char *busid);
+
+#define DRM_NODE_PRIMARY 0
+#define DRM_NODE_CONTROL 1
+#define DRM_NODE_RENDER  2
+#define DRM_NODE_MAX     3
+
+extern int           drmOpenWithType(const char *name, const char *busid,
+                                     int type);
+
+extern int           drmOpenControl(int minor);
+extern int           drmOpenRender(int minor);
+extern int           drmClose(int fd);
+extern drmVersionPtr drmGetVersion(int fd);
+extern drmVersionPtr drmGetLibVersion(int fd);
+extern int           drmGetCap(int fd, uint64_t capability, uint64_t *value);
+extern void          drmFreeVersion(drmVersionPtr);
+extern int           drmGetMagic(int fd, drm_magic_t * magic);
+extern char          *drmGetBusid(int fd);
+extern int           drmGetInterruptFromBusID(int fd, int busnum, int devnum,
+					      int funcnum);
+extern int           drmGetMap(int fd, int idx, drm_handle_t *offset,
+			       drmSize *size, drmMapType *type,
+			       drmMapFlags *flags, drm_handle_t *handle,
+			       int *mtrr);
+extern int           drmGetClient(int fd, int idx, int *auth, int *pid,
+				  int *uid, unsigned long *magic,
+				  unsigned long *iocs);
+extern int           drmGetStats(int fd, drmStatsT *stats);
+extern int           drmSetInterfaceVersion(int fd, drmSetVersion *version);
+extern int           drmCommandNone(int fd, unsigned long drmCommandIndex);
+extern int           drmCommandRead(int fd, unsigned long drmCommandIndex,
+                                    void *data, unsigned long size);
+extern int           drmCommandWrite(int fd, unsigned long drmCommandIndex,
+                                     void *data, unsigned long size);
+extern int           drmCommandWriteRead(int fd, unsigned long drmCommandIndex,
+                                         void *data, unsigned long size);
+
+/* General user-level programmer's API: X server (root) only  */
+extern void          drmFreeBusid(const char *busid);
+extern int           drmSetBusid(int fd, const char *busid);
+extern int           drmAuthMagic(int fd, drm_magic_t magic);
+extern int           drmAddMap(int fd,
+			       drm_handle_t offset,
+			       drmSize size,
+			       drmMapType type,
+			       drmMapFlags flags,
+			       drm_handle_t * handle);
+extern int	     drmRmMap(int fd, drm_handle_t handle);
+extern int	     drmAddContextPrivateMapping(int fd, drm_context_t ctx_id,
+						 drm_handle_t handle);
+
+extern int           drmAddBufs(int fd, int count, int size,
+				drmBufDescFlags flags,
+				int agp_offset);
+extern int           drmMarkBufs(int fd, double low, double high);
+extern int           drmCreateContext(int fd, drm_context_t * handle);
+extern int           drmSetContextFlags(int fd, drm_context_t context,
+					drm_context_tFlags flags);
+extern int           drmGetContextFlags(int fd, drm_context_t context,
+					drm_context_tFlagsPtr flags);
+extern int           drmAddContextTag(int fd, drm_context_t context, void *tag);
+extern int           drmDelContextTag(int fd, drm_context_t context);
+extern void          *drmGetContextTag(int fd, drm_context_t context);
+extern drm_context_t * drmGetReservedContextList(int fd, int *count);
+extern void          drmFreeReservedContextList(drm_context_t *);
+extern int           drmSwitchToContext(int fd, drm_context_t context);
+extern int           drmDestroyContext(int fd, drm_context_t handle);
+extern int           drmCreateDrawable(int fd, drm_drawable_t * handle);
+extern int           drmDestroyDrawable(int fd, drm_drawable_t handle);
+extern int           drmUpdateDrawableInfo(int fd, drm_drawable_t handle,
+					   drm_drawable_info_type_t type,
+					   unsigned int num, void *data);
+extern int           drmCtlInstHandler(int fd, int irq);
+extern int           drmCtlUninstHandler(int fd);
+extern int           drmSetClientCap(int fd, uint64_t capability,
+				     uint64_t value);
+
+extern int           drmCrtcGetSequence(int fd, uint32_t crtcId,
+					uint64_t *sequence, uint64_t *ns);
+extern int           drmCrtcQueueSequence(int fd, uint32_t crtcId,
+					  uint32_t flags, uint64_t sequence,
+					  uint64_t *sequence_queued,
+					  uint64_t user_data);
+/* General user-level programmer's API: authenticated client and/or X */
+extern int           drmMap(int fd,
+			    drm_handle_t handle,
+			    drmSize size,
+			    drmAddressPtr address);
+extern int           drmUnmap(drmAddress address, drmSize size);
+extern drmBufInfoPtr drmGetBufInfo(int fd);
+extern drmBufMapPtr  drmMapBufs(int fd);
+extern int           drmUnmapBufs(drmBufMapPtr bufs);
+extern int           drmDMA(int fd, drmDMAReqPtr request);
+extern int           drmFreeBufs(int fd, int count, int *list);
+extern int           drmGetLock(int fd,
+			        drm_context_t context,
+			        drmLockFlags flags);
+extern int           drmUnlock(int fd, drm_context_t context);
+extern int           drmFinish(int fd, int context, drmLockFlags flags);
+extern int	     drmGetContextPrivateMapping(int fd, drm_context_t ctx_id, 
+						 drm_handle_t * handle);
+
+/* AGP/GART support: X server (root) only */
+extern int           drmAgpAcquire(int fd);
+extern int           drmAgpRelease(int fd);
+extern int           drmAgpEnable(int fd, unsigned long mode);
+extern int           drmAgpAlloc(int fd, unsigned long size,
+				 unsigned long type, unsigned long *address,
+				 drm_handle_t *handle);
+extern int           drmAgpFree(int fd, drm_handle_t handle);
+extern int 	     drmAgpBind(int fd, drm_handle_t handle,
+				unsigned long offset);
+extern int           drmAgpUnbind(int fd, drm_handle_t handle);
+
+/* AGP/GART info: authenticated client and/or X */
+extern int           drmAgpVersionMajor(int fd);
+extern int           drmAgpVersionMinor(int fd);
+extern unsigned long drmAgpGetMode(int fd);
+extern unsigned long drmAgpBase(int fd); /* Physical location */
+extern unsigned long drmAgpSize(int fd); /* Bytes */
+extern unsigned long drmAgpMemoryUsed(int fd);
+extern unsigned long drmAgpMemoryAvail(int fd);
+extern unsigned int  drmAgpVendorId(int fd);
+extern unsigned int  drmAgpDeviceId(int fd);
+
+/* PCI scatter/gather support: X server (root) only */
+extern int           drmScatterGatherAlloc(int fd, unsigned long size,
+					   drm_handle_t *handle);
+extern int           drmScatterGatherFree(int fd, drm_handle_t handle);
+
+extern int           drmWaitVBlank(int fd, drmVBlankPtr vbl);
+
+/* Support routines */
+extern void          drmSetServerInfo(drmServerInfoPtr info);
+extern int           drmError(int err, const char *label);
+extern void          *drmMalloc(int size);
+extern void          drmFree(void *pt);
+
+/* Hash table routines */
+extern void *drmHashCreate(void);
+extern int  drmHashDestroy(void *t);
+extern int  drmHashLookup(void *t, unsigned long key, void **value);
+extern int  drmHashInsert(void *t, unsigned long key, void *value);
+extern int  drmHashDelete(void *t, unsigned long key);
+extern int  drmHashFirst(void *t, unsigned long *key, void **value);
+extern int  drmHashNext(void *t, unsigned long *key, void **value);
+
+/* PRNG routines */
+extern void          *drmRandomCreate(unsigned long seed);
+extern int           drmRandomDestroy(void *state);
+extern unsigned long drmRandom(void *state);
+extern double        drmRandomDouble(void *state);
+
+/* Skip list routines */
+
+extern void *drmSLCreate(void);
+extern int  drmSLDestroy(void *l);
+extern int  drmSLLookup(void *l, unsigned long key, void **value);
+extern int  drmSLInsert(void *l, unsigned long key, void *value);
+extern int  drmSLDelete(void *l, unsigned long key);
+extern int  drmSLNext(void *l, unsigned long *key, void **value);
+extern int  drmSLFirst(void *l, unsigned long *key, void **value);
+extern void drmSLDump(void *l);
+extern int  drmSLLookupNeighbors(void *l, unsigned long key,
+				 unsigned long *prev_key, void **prev_value,
+				 unsigned long *next_key, void **next_value);
+
+extern int drmOpenOnce(void *unused, const char *BusID, int *newlyopened);
+extern int drmOpenOnceWithType(const char *BusID, int *newlyopened, int type);
+extern void drmCloseOnce(int fd);
+extern void drmMsg(const char *format, ...) DRM_PRINTFLIKE(1, 2);
+
+extern int drmSetMaster(int fd);
+extern int drmDropMaster(int fd);
+extern int drmIsMaster(int fd);
+
+#define DRM_EVENT_CONTEXT_VERSION 4
+
+typedef struct _drmEventContext {
+
+	/* This struct is versioned so we can add more pointers if we
+	 * add more events. */
+	int version;
+
+	void (*vblank_handler)(int fd,
+			       unsigned int sequence, 
+			       unsigned int tv_sec,
+			       unsigned int tv_usec,
+			       void *user_data);
+
+	void (*page_flip_handler)(int fd,
+				  unsigned int sequence,
+				  unsigned int tv_sec,
+				  unsigned int tv_usec,
+				  void *user_data);
+
+	void (*page_flip_handler2)(int fd,
+				   unsigned int sequence,
+				   unsigned int tv_sec,
+				   unsigned int tv_usec,
+				   unsigned int crtc_id,
+				   void *user_data);
+
+	void (*sequence_handler)(int fd,
+				 uint64_t sequence,
+				 uint64_t ns,
+				 uint64_t user_data);
+} drmEventContext, *drmEventContextPtr;
+
+extern int drmHandleEvent(int fd, drmEventContextPtr evctx);
+
+extern char *drmGetDeviceNameFromFd(int fd);
+
+/* Improved version of drmGetDeviceNameFromFd which attributes for any type of
+ * device/node - card, control or renderD.
+ */
+extern char *drmGetDeviceNameFromFd2(int fd);
+extern int drmGetNodeTypeFromFd(int fd);
+
+extern int drmPrimeHandleToFD(int fd, uint32_t handle, uint32_t flags, int *prime_fd);
+extern int drmPrimeFDToHandle(int fd, int prime_fd, uint32_t *handle);
+
+extern char *drmGetPrimaryDeviceNameFromFd(int fd);
+extern char *drmGetRenderDeviceNameFromFd(int fd);
+
+#define DRM_BUS_PCI       0
+#define DRM_BUS_USB       1
+#define DRM_BUS_PLATFORM  2
+#define DRM_BUS_HOST1X    3
+
+typedef struct _drmPciBusInfo {
+    uint16_t domain;
+    uint8_t bus;
+    uint8_t dev;
+    uint8_t func;
+} drmPciBusInfo, *drmPciBusInfoPtr;
+
+typedef struct _drmPciDeviceInfo {
+    uint16_t vendor_id;
+    uint16_t device_id;
+    uint16_t subvendor_id;
+    uint16_t subdevice_id;
+    uint8_t revision_id;
+} drmPciDeviceInfo, *drmPciDeviceInfoPtr;
+
+typedef struct _drmUsbBusInfo {
+    uint8_t bus;
+    uint8_t dev;
+} drmUsbBusInfo, *drmUsbBusInfoPtr;
+
+typedef struct _drmUsbDeviceInfo {
+    uint16_t vendor;
+    uint16_t product;
+} drmUsbDeviceInfo, *drmUsbDeviceInfoPtr;
+
+#define DRM_PLATFORM_DEVICE_NAME_LEN 512
+
+typedef struct _drmPlatformBusInfo {
+    char fullname[DRM_PLATFORM_DEVICE_NAME_LEN];
+} drmPlatformBusInfo, *drmPlatformBusInfoPtr;
+
+typedef struct _drmPlatformDeviceInfo {
+    char **compatible; /* NULL terminated list of compatible strings */
+} drmPlatformDeviceInfo, *drmPlatformDeviceInfoPtr;
+
+#define DRM_HOST1X_DEVICE_NAME_LEN 512
+
+typedef struct _drmHost1xBusInfo {
+    char fullname[DRM_HOST1X_DEVICE_NAME_LEN];
+} drmHost1xBusInfo, *drmHost1xBusInfoPtr;
+
+typedef struct _drmHost1xDeviceInfo {
+    char **compatible; /* NULL terminated list of compatible strings */
+} drmHost1xDeviceInfo, *drmHost1xDeviceInfoPtr;
+
+typedef struct _drmDevice {
+    char **nodes; /* DRM_NODE_MAX sized array */
+    int available_nodes; /* DRM_NODE_* bitmask */
+    int bustype;
+    union {
+        drmPciBusInfoPtr pci;
+        drmUsbBusInfoPtr usb;
+        drmPlatformBusInfoPtr platform;
+        drmHost1xBusInfoPtr host1x;
+    } businfo;
+    union {
+        drmPciDeviceInfoPtr pci;
+        drmUsbDeviceInfoPtr usb;
+        drmPlatformDeviceInfoPtr platform;
+        drmHost1xDeviceInfoPtr host1x;
+    } deviceinfo;
+} drmDevice, *drmDevicePtr;
+
+extern int drmGetDevice(int fd, drmDevicePtr *device);
+extern void drmFreeDevice(drmDevicePtr *device);
+
+extern int drmGetDevices(drmDevicePtr devices[], int max_devices);
+extern void drmFreeDevices(drmDevicePtr devices[], int count);
+
+#define DRM_DEVICE_GET_PCI_REVISION (1 << 0)
+extern int drmGetDevice2(int fd, uint32_t flags, drmDevicePtr *device);
+extern int drmGetDevices2(uint32_t flags, drmDevicePtr devices[], int max_devices);
+
+extern int drmDevicesEqual(drmDevicePtr a, drmDevicePtr b);
+
+extern int drmSyncobjCreate(int fd, uint32_t flags, uint32_t *handle);
+extern int drmSyncobjDestroy(int fd, uint32_t handle);
+extern int drmSyncobjHandleToFD(int fd, uint32_t handle, int *obj_fd);
+extern int drmSyncobjFDToHandle(int fd, int obj_fd, uint32_t *handle);
+
+extern int drmSyncobjImportSyncFile(int fd, uint32_t handle, int sync_file_fd);
+extern int drmSyncobjExportSyncFile(int fd, uint32_t handle, int *sync_file_fd);
+extern int drmSyncobjWait(int fd, uint32_t *handles, unsigned num_handles,
+			  int64_t timeout_nsec, unsigned flags,
+			  uint32_t *first_signaled);
+extern int drmSyncobjReset(int fd, const uint32_t *handles, uint32_t handle_count);
+extern int drmSyncobjSignal(int fd, const uint32_t *handles, uint32_t handle_count);
+extern int drmSyncobjTimelineSignal(int fd, const uint32_t *handles,
+				    uint64_t *points, uint32_t handle_count);
+extern int drmSyncobjTransfer(int fd, uint32_t dst_handle, uint64_t dst_point,
+			      uint32_t src_handle, uint64_t src_point, uint32_t flags);
+extern int drmSyncobjTimelineWait(int fd, uint32_t *handles, uint64_t *points,
+				  unsigned num_handles, int64_t timeout_nsec,
+				  unsigned flags, uint32_t *first_signaled);
+extern int drmSyncobjQuery(int fd, uint32_t *handles, uint64_t *points,
+			   uint32_t handle_count);
+extern int drmSyncobjQuery2(int fd, uint32_t *handles, uint64_t *points,
+			   uint32_t handle_count, uint32_t flags);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif
diff --git a/src/c11/threads.h b/src/c11/threads.h
index 59baea11281..598948bf1cc 100644
--- a/src/c11/threads.h
+++ b/src/c11/threads.h
@@ -121,6 +121,8 @@ typedef struct
 {
    volatile uintptr_t status;
 } once_flag;
+// FIXME: temporary non-standard hack to ease transition
+#  define _MTX_INITIALIZER_NP {(void*)-1, -1, 0, 0, 0, 0}
 #  define ONCE_FLAG_INIT {0}
 #  define TSS_DTOR_ITERATIONS 1
 #elif defined(HAVE_PTHREAD)
diff --git a/src/gallium/drivers/virgl/meson.build b/src/gallium/drivers/virgl/meson.build
index 0bb26c67c7c..22b8f905f32 100644
--- a/src/gallium/drivers/virgl/meson.build
+++ b/src/gallium/drivers/virgl/meson.build
@@ -43,7 +43,7 @@ libvirgl = static_library(
 
 driver_virgl = declare_dependency(
   compile_args : '-DGALLIUM_VIRGL',
-  link_with : [libvirgl, libvirgldrm, libvirglvtest],
+  link_with : [libvirgl, libvirgldrm],
 )
 
 if with_tests
diff --git a/src/gallium/drivers/virgl/virgl_context.c b/src/gallium/drivers/virgl/virgl_context.c
index 40d1155bea7..41eb0dde9ae 100644
--- a/src/gallium/drivers/virgl/virgl_context.c
+++ b/src/gallium/drivers/virgl/virgl_context.c
@@ -21,7 +21,9 @@
  * USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
+#ifndef _WIN32
 #include <libsync.h>
+#endif
 #include "pipe/p_shader_tokens.h"
 
 #include "compiler/nir/nir.h"
diff --git a/src/gallium/drivers/virgl/virgl_screen.c b/src/gallium/drivers/virgl/virgl_screen.c
index a2766430c5f..73a75b10877 100644
--- a/src/gallium/drivers/virgl/virgl_screen.c
+++ b/src/gallium/drivers/virgl/virgl_screen.c
@@ -900,12 +900,11 @@ static void virgl_flush_frontbuffer(struct pipe_screen *screen,
 {
    struct virgl_screen *vscreen = virgl_screen(screen);
    struct virgl_winsys *vws = vscreen->vws;
-   struct virgl_resource *vres = virgl_resource(res);
    struct virgl_context *vctx = virgl_context(ctx);
 
    if (vws->flush_frontbuffer) {
       virgl_flush_eq(vctx, vctx, NULL);
-      vws->flush_frontbuffer(vws, vres->hw_res, level, layer, winsys_drawable_handle,
+      vws->flush_frontbuffer((struct pipe_screen*)vscreen, ctx, res, level, layer, winsys_drawable_handle,
                              sub_box);
    }
 }
@@ -1021,6 +1020,7 @@ static struct disk_cache *virgl_get_disk_shader_cache (struct pipe_screen *pscre
    return screen->disk_cache;
 }
 
+#ifdef ENABLE_SHADER_CACHE
 static void virgl_disk_cache_create(struct virgl_screen *screen)
 {
    const struct build_id_note *note =
@@ -1049,6 +1049,7 @@ static void virgl_disk_cache_create(struct virgl_screen *screen)
 
    screen->disk_cache = disk_cache_create("virgl", timestamp, 0);
 }
+#endif
 
 static bool
 virgl_is_dmabuf_modifier_supported(UNUSED struct pipe_screen *pscreen,
@@ -1185,6 +1186,8 @@ virgl_create_screen(struct virgl_winsys *vws, const struct pipe_screen_config *c
 
    slab_create_parent(&screen->transfer_pool, sizeof(struct virgl_transfer), 16);
 
+#ifdef ENABLE_SHADER_CACHE
    virgl_disk_cache_create(screen);
+#endif
    return &screen->base;
 }
diff --git a/src/gallium/drivers/virgl/virgl_video.c b/src/gallium/drivers/virgl/virgl_video.c
index fc2d1b5443d..2abf6768d75 100644
--- a/src/gallium/drivers/virgl/virgl_video.c
+++ b/src/gallium/drivers/virgl/virgl_video.c
@@ -106,7 +106,7 @@ static int fill_base_picture_desc(const struct pipe_picture_desc *desc,
     ITEM_SET(vbase, desc, protected_playback);
     ITEM_SET(vbase, desc, key_size);
     memcpy(vbase->decrypt_key, desc->decrypt_key,
-           MIN(desc->key_size, sizeof(vbase->decrypt_key)));
+           MIN2(desc->key_size, sizeof(vbase->decrypt_key)));
 
     return 0;
 }
diff --git a/src/gallium/drivers/virgl/virgl_winsys.h b/src/gallium/drivers/virgl/virgl_winsys.h
index 13e82b033b4..bed21a2ab1d 100644
--- a/src/gallium/drivers/virgl/virgl_winsys.h
+++ b/src/gallium/drivers/virgl/virgl_winsys.h
@@ -45,6 +45,8 @@ struct virgl_cmd_buf {
 };
 
 struct virgl_winsys {
+   struct sw_winsys *winsys;
+
    unsigned pci_id;
    int supports_fences; /* In/Out fences are supported */
    int supports_encoded_transfers; /* Encoded transfers are supported */
@@ -130,11 +132,13 @@ struct virgl_winsys {
                            struct pipe_fence_handle *src);
 
    /* for sw paths */
-   void (*flush_frontbuffer)(struct virgl_winsys *vws,
-                             struct virgl_hw_res *res,
+   void (*flush_frontbuffer)(struct pipe_screen *screen,
+                             struct pipe_context *ctx,
+                             struct pipe_resource *res,
                              unsigned level, unsigned layer,
                              void *winsys_drawable_handle,
                              struct pipe_box *sub_box);
+
    void (*fence_server_sync)(struct virgl_winsys *vws,
                              struct virgl_cmd_buf *cbuf,
                              struct pipe_fence_handle *fence);
diff --git a/src/gallium/meson.build b/src/gallium/meson.build
index 148c7220382..d307c71a138 100644
--- a/src/gallium/meson.build
+++ b/src/gallium/meson.build
@@ -152,9 +152,9 @@ else
   driver_svga = declare_dependency()
 endif
 if with_gallium_virgl
+  subdir('winsys/virgl/lib')
   subdir('winsys/virgl/common')
   subdir('winsys/virgl/drm')
-  subdir('winsys/virgl/vtest')
   subdir('drivers/virgl')
 else
   driver_virgl = declare_dependency()
diff --git a/src/gallium/targets/wgl/meson.build b/src/gallium/targets/wgl/meson.build
index eaca0aec86b..433d24ed395 100644
--- a/src/gallium/targets/wgl/meson.build
+++ b/src/gallium/targets/wgl/meson.build
@@ -41,7 +41,7 @@ libgallium_wgl = shared_library(
     libgallium, libglsl, libmesa, libwsgdi, libglapi_static, libglapi, libgalliumvl
   ],
   dependencies : [
-    dep_ws2_32, idep_nir, idep_mesautil, driver_swrast,
+    dep_ws2_32, idep_nir, idep_mesautil, driver_swrast, driver_virgl,
     driver_d3d12, driver_zink, winsys_d3d12_wgl
   ],
   link_args : gallium_wgl_link_args,
diff --git a/src/gallium/targets/wgl/wgl.c b/src/gallium/targets/wgl/wgl.c
index da44e146488..5f174e47a7d 100644
--- a/src/gallium/targets/wgl/wgl.c
+++ b/src/gallium/targets/wgl/wgl.c
@@ -35,6 +35,7 @@
 
 
 #include <windows.h>
+#include <bcrypt.h>
 
 #include "util/u_debug.h"
 #include "stw_winsys.h"
@@ -43,6 +44,10 @@
 #include "pipe/p_screen.h"
 #include "pipe/p_context.h"
 
+#ifdef _WIN32
+#include "../../winsys/virgl/lib/vgpu_api.h"
+#endif
+
 #ifdef GALLIUM_SOFTPIPE
 #include "softpipe/sp_texture.h"
 #include "softpipe/sp_screen.h"
@@ -63,6 +68,10 @@
 #include "zink/zink_public.h"
 #endif
 
+#ifdef GALLIUM_VIRGL
+#include "virgl/drm/virgl_drm_public.h"
+#endif
+
 #ifdef GALLIUM_LLVMPIPE
 static boolean use_llvmpipe = FALSE;
 #endif
@@ -72,7 +81,11 @@ static boolean use_d3d12 = FALSE;
 #ifdef GALLIUM_ZINK
 static boolean use_zink = FALSE;
 #endif
+#ifdef GALLIUM_VIRGL
+static boolean use_virgl = FALSE;
+#endif
 
+static HANDLE vgpu_handle = INVALID_HANDLE_VALUE;
 static const char *created_driver_name = NULL;
 
 static struct pipe_screen *
@@ -106,7 +119,17 @@ wgl_screen_create_by_name(HDC hDC, const char* driver, struct sw_winsys *winsys)
       screen = softpipe_create_screen(winsys);
    }
 #endif
-
+#ifdef GALLIUM_VIRGL
+   if (strcmp(driver, "virgl") == 0) {
+      assert(vgpu_handle == INVALID_HANDLE_VALUE);
+
+      vgpu_handle = GetHandleFromVgpu();
+      CreateVirglContext(vgpu_handle);
+      
+      screen = virgl_drm_screen_create(vgpu_handle, NULL, winsys);
+      use_virgl = TRUE;
+   }
+#endif
    return screen;
 }
 
@@ -128,6 +151,9 @@ wgl_screen_create(HDC hDC)
 #ifdef GALLIUM_ZINK
       sw_only ? "" : "zink",
 #endif
+#ifdef GALLIUM_VIRGL
+      sw_only ? "" : "virgl",
+#endif
 #if defined(GALLIUM_LLVMPIPE)
       "llvmpipe",
 #endif
@@ -203,6 +229,13 @@ wgl_present(struct pipe_screen *screen,
    dt = softpipe_resource(res)->dt,
    gdi_sw_display(winsys, dt, hDC);
 #endif
+
+#ifdef GALLIUM_VIRGL
+   if (use_virgl) {
+      screen->flush_frontbuffer(screen, ctx, res, 0, 0, hDC, NULL);
+      return;
+   }
+#endif
 }
 
 
@@ -277,6 +310,7 @@ DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
 {
    switch (fdwReason) {
    case DLL_PROCESS_ATTACH:
+      _debug_printf("call DLL_PROCESS_ATTACH\n");
       stw_init(&stw_winsys);
       stw_init_thread();
       break;
@@ -290,6 +324,13 @@ DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
       break;
 
    case DLL_PROCESS_DETACH:
+      _debug_printf("call DLL_PROCESS_DETACH\n");
+#ifdef GALLIUM_VIRGL
+      if (vgpu_handle != INVALID_HANDLE_VALUE)
+      {
+         DestroyVirglContext(vgpu_handle);
+      }
+#endif
       if (lpvReserved == NULL) {
          // We're being unloaded from the process.
          stw_cleanup_thread();
diff --git a/src/gallium/winsys/virgl/drm/meson.build b/src/gallium/winsys/virgl/drm/meson.build
index 79bac2fd211..bd1f4712261 100644
--- a/src/gallium/winsys/virgl/drm/meson.build
+++ b/src/gallium/winsys/virgl/drm/meson.build
@@ -22,6 +22,6 @@ libvirgldrm = static_library(
   'virgldrm',
   'virgl_drm_winsys.c',
   include_directories : [inc_include, inc_src, inc_mapi, inc_mesa, inc_gallium, inc_gallium_aux, inc_gallium_drivers, inc_virtio],
-  dependencies : [dep_libdrm, dep_libvirglcommon, idep_mesautil, idep_nir_headers],
+  dependencies : [dep_libdrm, dep_libvirglcommon, idep_mesautil, idep_nir_headers, dep_libvgpuapi],
   gnu_symbol_visibility : 'hidden',
 )
diff --git a/src/gallium/winsys/virgl/drm/virgl_drm_public.h b/src/gallium/winsys/virgl/drm/virgl_drm_public.h
index 32df3945ff4..c3a4fd4f49d 100644
--- a/src/gallium/winsys/virgl/drm/virgl_drm_public.h
+++ b/src/gallium/winsys/virgl/drm/virgl_drm_public.h
@@ -25,6 +25,6 @@
 
 struct pipe_screen;
 
-struct pipe_screen *virgl_drm_screen_create(int fd, const struct pipe_screen_config *config);
+struct pipe_screen* virgl_drm_screen_create(HANDLE fd, const struct pipe_screen_config *config, struct sw_winsys *winsys);
 
 #endif
diff --git a/src/gallium/winsys/virgl/drm/virgl_drm_winsys.c b/src/gallium/winsys/virgl/drm/virgl_drm_winsys.c
index 6ae63e75758..2ef6820df66 100644
--- a/src/gallium/winsys/virgl/drm/virgl_drm_winsys.c
+++ b/src/gallium/winsys/virgl/drm/virgl_drm_winsys.c
@@ -25,10 +25,18 @@
 #include <fcntl.h>
 #include <limits.h>
 #include <stdio.h>
+
+#if _WIN32
+#include <windows.h>
+#include <bcrypt.h>
+#else
 #include <sys/ioctl.h>
 #include <sys/stat.h>
-
+#include <libsync.h>
+#include <xf86drm.h>
 #include "util/os_mman.h"
+#endif
+
 #include "util/os_file.h"
 #include "util/os_time.h"
 #include "util/u_memory.h"
@@ -36,18 +44,24 @@
 #include "util/u_hash_table.h"
 #include "util/u_inlines.h"
 #include "util/u_pointer.h"
+#include "frontend/sw_winsys.h"
 #include "frontend/drm_driver.h"
+#include "virgl/virgl_resource.h"
 #include "virgl/virgl_screen.h"
 #include "virgl/virgl_public.h"
 #include "virtio-gpu/virgl_protocol.h"
 
-#include <xf86drm.h>
-#include <libsync.h>
 #include "drm-uapi/virtgpu_drm.h"
 
 #include "virgl_drm_winsys.h"
 #include "virgl_drm_public.h"
 
+#ifdef _WIN32
+#include "../lib/vgpu_api.h"
+#endif
+
+#define PAGE_SIZE 4096
+
 // Delete local definitions when virglrenderer_hw.h becomes public
 #define VIRGL_DRM_CAPSET_VIRGL  1
 #define VIRGL_DRM_CAPSET_VIRGL2 2
@@ -93,8 +107,14 @@ static void virgl_hw_res_destroy(struct virgl_drm_winsys *qdws,
          _mesa_hash_table_remove_key(qdws->bo_names,
                                 (void *)(uintptr_t)res->flink_name);
       mtx_unlock(&qdws->bo_handles_mutex);
-      if (res->ptr)
+
+      if (res->ptr) {
+#ifdef _WIN32
+         // unmap resource in driver
+#else
          os_munmap(res->ptr, res->size);
+#endif
+      }
 
       memset(&args, 0, sizeof(args));
       args.handle = res->bo_handle;
@@ -117,8 +137,14 @@ static boolean virgl_drm_resource_is_busy(struct virgl_winsys *vws,
    waitcmd.flags = VIRTGPU_WAIT_NOWAIT;
 
    ret = drmIoctl(vdws->fd, DRM_IOCTL_VIRTGPU_WAIT, &waitcmd);
+
+#ifdef _WIN32
+   if (ret == 1)
+      return TRUE;
+#else
    if (ret && errno == EBUSY)
       return TRUE;
+#endif
 
    p_atomic_set(&res->maybe_busy, false);
 
@@ -200,8 +226,15 @@ virgl_drm_winsys_resource_create_blob(struct virgl_winsys *qws,
    /* Make sure blob is page aligned. */
    if (flags & (VIRGL_RESOURCE_FLAG_MAP_PERSISTENT |
                 VIRGL_RESOURCE_FLAG_MAP_COHERENT)) {
+#ifdef _WIN32
+      uint64_t page_size;
+      assert(os_get_page_size(&page_size) == true);
+      width = ALIGN(width, page_size);
+      size = ALIGN(size, page_size);
+#else
       width = ALIGN(width, getpagesize());
       size = ALIGN(size, getpagesize());
+#endif
    }
 
    blob_id = p_atomic_inc_return(&qdws->blob_id);
@@ -218,7 +251,7 @@ virgl_drm_winsys_resource_create_blob(struct virgl_winsys *qws,
    cmd[VIRGL_PIPE_RES_CREATE_FLAGS] = flags;
    cmd[VIRGL_PIPE_RES_CREATE_BLOB_ID] = blob_id;
 
-   drm_rc_blob.cmd = (unsigned long)(void *)&cmd;
+   drm_rc_blob.cmd = (uint64_t)(void *)&cmd;
    drm_rc_blob.cmd_size = 4 * (VIRGL_PIPE_RES_CREATE_SIZE + 1);
    drm_rc_blob.size = size;
    drm_rc_blob.blob_mem = VIRTGPU_BLOB_MEM_HOST3D;
@@ -475,6 +508,13 @@ virgl_drm_winsys_resource_create_handle(struct virgl_winsys *qws,
                                         uint64_t *modifier,
                                         uint32_t *blob_mem)
 {
+#ifdef _WIN32
+   _debug_printf("virgl_drm_winsys_resource_create_handle not implememt\n");
+   assert(0);
+
+   return NULL;
+#else
+
    struct virgl_drm_winsys *qdws = virgl_drm_winsys(qws);
    struct drm_gem_open open_arg = {};
    struct drm_virtgpu_resource_info info_arg = {};
@@ -573,6 +613,8 @@ virgl_drm_winsys_resource_create_handle(struct virgl_winsys *qws,
 done:
    mtx_unlock(&qdws->bo_handles_mutex);
    return res;
+
+#endif
 }
 
 static void
@@ -632,6 +674,13 @@ static boolean virgl_drm_winsys_resource_get_handle(struct virgl_winsys *qws,
                                                     uint32_t stride,
                                                     struct winsys_handle *whandle)
  {
+#ifdef _WIN32
+   _debug_printf("virgl_drm_winsys_resource_get_handle not implememt\n");
+   assert(0);
+
+   return FALSE;
+#else
+
    struct virgl_drm_winsys *qdws = virgl_drm_winsys(qws);
    struct drm_gem_flink flink;
 
@@ -667,6 +716,8 @@ static boolean virgl_drm_winsys_resource_get_handle(struct virgl_winsys *qws,
 
    whandle->stride = stride;
    return TRUE;
+
+#endif
 }
 
 static void *virgl_drm_resource_map(struct virgl_winsys *qws,
@@ -684,10 +735,14 @@ static void *virgl_drm_resource_map(struct virgl_winsys *qws,
    if (drmIoctl(qdws->fd, DRM_IOCTL_VIRTGPU_MAP, &mmap_arg))
       return NULL;
 
+#ifdef _WIN32
+   ptr = (void*)mmap_arg.offset;
+#else
    ptr = os_mmap(0, res->size, PROT_READ|PROT_WRITE, MAP_SHARED,
                  qdws->fd, mmap_arg.offset);
    if (ptr == MAP_FAILED)
       return NULL;
+#endif
 
    res->ptr = ptr;
    return ptr;
@@ -953,10 +1008,10 @@ static int virgl_drm_winsys_submit_cmd(struct virgl_winsys *qws,
       return 0;
 
    memset(&eb, 0, sizeof(struct drm_virtgpu_execbuffer));
-   eb.command = (unsigned long)(void*)cbuf->buf;
+   eb.command = (uint64_t)(void*)cbuf->buf;
    eb.size = cbuf->base.cdw * 4;
    eb.num_bo_handles = cbuf->cres;
-   eb.bo_handles = (unsigned long)(void *)cbuf->res_hlist;
+   eb.bo_handles = (uint64_t)(void *)cbuf->res_hlist;
 
    eb.fence_fd = -1;
    if (qws->supports_fences) {
@@ -1012,7 +1067,7 @@ static int virgl_drm_get_caps(struct virgl_winsys *vws,
       args.cap_set_id = 1;
       args.size = sizeof(struct virgl_caps_v1);
    }
-   args.addr = (unsigned long)&caps->caps;
+   args.addr = (uint64_t)&caps->caps;
 
    ret = drmIoctl(vdws->fd, DRM_IOCTL_VIRTGPU_GET_CAPS, &args);
    if (ret == -1 && errno == EINVAL) {
@@ -1023,6 +1078,8 @@ static int virgl_drm_get_caps(struct virgl_winsys *vws,
       if (ret == -1)
           return ret;
    }
+
+   _debug_printf("glsl_level=%d\n", caps->caps.v1.glsl_level);
    return ret;
 }
 
@@ -1041,6 +1098,9 @@ static bool virgl_fence_wait(struct virgl_winsys *vws,
 {
    struct virgl_drm_fence *fence = virgl_drm_fence(_fence);
 
+#ifdef _WIN32
+   assert(!vws->supports_fences);
+#else
    if (vws->supports_fences) {
       uint64_t timeout_ms;
       int timeout_poll;
@@ -1057,6 +1117,7 @@ static bool virgl_fence_wait(struct virgl_winsys *vws,
 
       return sync_wait(fence->fd, timeout_poll) == 0;
    }
+#endif
 
    if (timeout == 0)
       return !virgl_drm_resource_is_busy(vws, fence->hw_res);
@@ -1109,7 +1170,13 @@ static void virgl_fence_server_sync(struct virgl_winsys *vws,
    if (!fence->external)
       return;
 
+#ifdef _WIN32
+   UNREFERENCED_PARAMETER(cbuf);
+   _debug_printf("sync_accumulate not implemented\n");
+   assert(0);
+#else
    sync_accumulate("virgl", &cbuf->in_fence_fd, fence->fd);
+#endif
 }
 
 static int virgl_fence_get_fd(struct virgl_winsys *vws,
@@ -1123,7 +1190,7 @@ static int virgl_fence_get_fd(struct virgl_winsys *vws,
    return os_dupfd_cloexec(fence->fd);
 }
 
-static int virgl_drm_get_version(int fd)
+static int virgl_drm_get_version(HANDLE fd)
 {
 	int ret;
 	drmVersionPtr version;
@@ -1162,7 +1229,7 @@ virgl_drm_resource_cache_entry_release(struct virgl_resource_cache_entry *entry,
    virgl_hw_res_destroy(qdws, res);
 }
 
-static int virgl_init_context(int drmFD)
+static int virgl_init_context(HANDLE drmFD)
 {
    int ret;
    struct drm_virtgpu_context_init init = { 0 };
@@ -1186,7 +1253,7 @@ static int virgl_init_context(int drmFD)
                          VIRGL_DRM_CAPSET_VIRGL2 :
                          VIRGL_DRM_CAPSET_VIRGL;
 
-   init.ctx_set_params = (unsigned long)(void *)&ctx_set_param;
+   init.ctx_set_params = (uint64_t)(void *)&ctx_set_param;
    init.num_params = 1;
 
    ret = drmIoctl(drmFD, DRM_IOCTL_VIRTGPU_CONTEXT_INIT, &init);
@@ -1203,8 +1270,52 @@ static int virgl_init_context(int drmFD)
    return 0;
 }
 
+static void virgl_flush_frontbuffer(struct pipe_screen *screen,
+                                    struct pipe_context *ctx,
+                                    struct pipe_resource *res,
+                                    unsigned level, unsigned layer,
+                                    void *winsys_drawable_handle, struct pipe_box *sub_box)
+{
+   struct virgl_screen *vscreen = virgl_screen(screen);
+   struct virgl_resource *vres = virgl_resource(res);
+
+   unsigned int stride;
+   if (!vres->hw_res->dt) {
+      struct sw_winsys *winsys = vscreen->vws->winsys;
+      vres->hw_res->dt = winsys->displaytarget_create(winsys,
+                                             res->bind,
+                                             res->format,
+                                             res->width0, res->height0,
+                                             64,
+                                             NULL,
+                                             &stride);
+   } else {
+      stride = align(res->width0 * util_format_get_blocksize(res->format), 64);
+   }
+   assert(vres->hw_res->dt && vres->b.target == PIPE_TEXTURE_2D);
+
+   void *screen_map = vscreen->vws->winsys->displaytarget_map(vscreen->vws->winsys, vres->hw_res->dt, 0);
+   assert(screen_map);
+
+   struct pipe_transfer *transfer;
+   void *res_map = pipe_texture_map(ctx, res, level, layer, PIPE_MAP_READ, 0, 0, res->width0, res->height0, &transfer);
+   assert(res_map && transfer);
+
+   // copy the 2d display resource to pipe screen
+   util_copy_rect((ubyte*)screen_map, res->format, stride, 0, 0,
+                  transfer->box.width, transfer->box.height,
+                  (const ubyte*)res_map, transfer->stride, 0, 0);
+
+   pipe_texture_unmap(ctx, transfer);
+   vscreen->vws->winsys->displaytarget_unmap(vscreen->vws->winsys, vres->hw_res->dt);
+
+   // display
+   vscreen->vws->winsys->displaytarget_display(vscreen->vws->winsys, vres->hw_res->dt, winsys_drawable_handle, sub_box);
+   return;
+}
+
 static struct virgl_winsys *
-virgl_drm_winsys_create(int drmFD)
+virgl_drm_winsys_create(HANDLE drmFD)
 {
    static const unsigned CACHE_TIMEOUT_USEC = 1000000;
    struct virgl_drm_winsys *qdws;
@@ -1218,6 +1329,7 @@ virgl_drm_winsys_create(int drmFD)
       getparam.value = (uint64_t)(uintptr_t)&value;
       ret = drmIoctl(drmFD, DRM_IOCTL_VIRTGPU_GETPARAM, &getparam);
       params[i].value = (ret == 0) ? value : 0;
+      _debug_printf("param=%d value=%ld\n", params[i].param, params[i].value);
    }
 
    if (!params[param_3d_features].value)
@@ -1266,6 +1378,7 @@ virgl_drm_winsys_create(int drmFD)
    qdws->base.submit_cmd = virgl_drm_winsys_submit_cmd;
    qdws->base.emit_res = virgl_drm_emit_res;
    qdws->base.res_is_referenced = virgl_drm_res_is_ref;
+   qdws->base.flush_frontbuffer = virgl_flush_frontbuffer;
 
    qdws->base.cs_create_fence = virgl_cs_create_fence;
    qdws->base.fence_wait = virgl_fence_wait;
@@ -1294,9 +1407,9 @@ virgl_drm_screen_destroy(struct pipe_screen *pscreen)
    mtx_lock(&virgl_screen_mutex);
    destroy = --screen->refcnt == 0;
    if (destroy) {
-      int fd = virgl_drm_winsys(screen->vws)->fd;
-      _mesa_hash_table_remove_key(fd_tab, intptr_to_pointer(fd));
-      close(fd);
+      HANDLE fd = virgl_drm_winsys(screen->vws)->fd;
+      _mesa_hash_table_remove_key(fd_tab, fd);
+      CloseHandle(fd);
    }
    mtx_unlock(&virgl_screen_mutex);
 
@@ -1343,8 +1456,9 @@ equal_fd(const void *key1, const void *key2)
    return false;
 }
 
+/* pipe_screen is needed for create pipe_context */
 struct pipe_screen *
-virgl_drm_screen_create(int fd, const struct pipe_screen_config *config)
+virgl_drm_screen_create(HANDLE fd, const struct pipe_screen_config *config, struct sw_winsys *winsys)
 {
    struct pipe_screen *pscreen = NULL;
 
@@ -1355,22 +1469,22 @@ virgl_drm_screen_create(int fd, const struct pipe_screen_config *config)
          goto unlock;
    }
 
-   pscreen = util_hash_table_get(fd_tab, intptr_to_pointer(fd));
+   pscreen = util_hash_table_get(fd_tab, fd);
    if (pscreen) {
       virgl_screen(pscreen)->refcnt++;
    } else {
       struct virgl_winsys *vws;
-      int dup_fd = os_dupfd_cloexec(fd);
 
-      vws = virgl_drm_winsys_create(dup_fd);
+      vws = virgl_drm_winsys_create(fd);
       if (!vws) {
-         close(dup_fd);
+         CloseHandle(fd);
          goto unlock;
       }
+      vws->winsys = winsys;
 
       pscreen = virgl_create_screen(vws, config);
       if (pscreen) {
-         _mesa_hash_table_insert(fd_tab, intptr_to_pointer(dup_fd), pscreen);
+         _mesa_hash_table_insert(fd_tab, fd, pscreen);
 
          /* Bit of a hack, to avoid circular linkage dependency,
           * ie. pipe driver having to call in to winsys, we
@@ -1383,5 +1497,9 @@ virgl_drm_screen_create(int fd, const struct pipe_screen_config *config)
 
 unlock:
    mtx_unlock(&virgl_screen_mutex);
+   if (!pscreen) {
+      _debug_printf("virgl_drm_screen_create failed err=%d\n", GetLastError());
+   }
+
    return pscreen;
 }
diff --git a/src/gallium/winsys/virgl/drm/virgl_drm_winsys.h b/src/gallium/winsys/virgl/drm/virgl_drm_winsys.h
index f17d89c098b..f256666b6ee 100644
--- a/src/gallium/winsys/virgl/drm/virgl_drm_winsys.h
+++ b/src/gallium/winsys/virgl/drm/virgl_drm_winsys.h
@@ -43,6 +43,8 @@ struct virgl_hw_res {
    uint32_t size;
    void *ptr;
 
+   struct sw_displaytarget *dt;
+
    struct virgl_resource_cache_entry cache_entry;
    uint32_t bind;
    uint32_t flags;
@@ -91,7 +93,7 @@ struct param params[] = { PARAM(VIRTGPU_PARAM_3D_FEATURES),
 struct virgl_drm_winsys
 {
    struct virgl_winsys base;
-   int fd;
+   HANDLE fd;
    struct virgl_resource_cache cache;
    mtx_t mutex;
 
diff --git a/src/gallium/winsys/virgl/lib/ioctl.h b/src/gallium/winsys/virgl/lib/ioctl.h
new file mode 100644
index 00000000000..29938c86bd0
--- /dev/null
+++ b/src/gallium/winsys/virgl/lib/ioctl.h
@@ -0,0 +1,82 @@
+/*
+ * MVisor vgpu Device guest driver
+ * Copyright (C) 2022 cair <rui.cai@tenclass.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+#ifndef IOCTL_H
+#define IOCTL_H
+
+#include <winioctl.h>
+#include <initguid.h> 
+
+// 31c22912-7210-11ed-bf22-bce92fa2e22d
+DEFINE_GUID(GUID_DEVINTERFACE_VGPU, 0x31c22912, 0x7210, 0x11ed, 0xbf, 0x22, 0xbc, 0xe9, 0x2f, 0xa2, 0xe2, 0x2d);
+
+#define IOCTL_VIRTIO_VGPU_CREATE_CONTEXT CTL_CODE(FILE_DEVICE_UNKNOWN, \
+    0x800, \
+    METHOD_OUT_DIRECT, \
+    FILE_ANY_ACCESS)
+
+#define IOCTL_VIRTIO_VGPU_DESTROY_CONTEXT CTL_CODE(FILE_DEVICE_UNKNOWN, \
+    0x801, \
+    METHOD_IN_DIRECT, \
+    FILE_ANY_ACCESS)
+
+#define IOCTL_VIRTIO_VGPU_MAP CTL_CODE(FILE_DEVICE_UNKNOWN, \
+    0x802, \
+    METHOD_OUT_DIRECT, \
+    FILE_ANY_ACCESS)
+
+#define IOCTL_VIRTIO_VGPU_EXECBUFFER CTL_CODE(FILE_DEVICE_UNKNOWN, \
+    0x803, \
+    METHOD_IN_DIRECT, \
+    FILE_ANY_ACCESS)
+
+#define IOCTL_VIRTIO_VGPU_GETPARAM CTL_CODE(FILE_DEVICE_UNKNOWN, \
+    0x804, \
+    METHOD_OUT_DIRECT, \
+    FILE_ANY_ACCESS)
+
+#define IOCTL_VIRTIO_VGPU_GET_CAPS CTL_CODE(FILE_DEVICE_UNKNOWN, \
+    0x805, \
+    METHOD_OUT_DIRECT, \
+    FILE_ANY_ACCESS)
+
+#define IOCTL_VIRTIO_VGPU_RESOURCE_CREATE CTL_CODE(FILE_DEVICE_UNKNOWN, \
+    0x806, \
+    METHOD_OUT_DIRECT, \
+    FILE_ANY_ACCESS)
+
+#define IOCTL_VIRTIO_VGPU_RESOURCE_CLOSE CTL_CODE(FILE_DEVICE_UNKNOWN, \
+    0x807, \
+    METHOD_IN_DIRECT, \
+    FILE_ANY_ACCESS)
+
+#define IOCTL_VIRTIO_VGPU_TRANSFER_FROM_HOST CTL_CODE(FILE_DEVICE_UNKNOWN, \
+    0x808, \
+    METHOD_IN_DIRECT, \
+    FILE_ANY_ACCESS)
+
+#define IOCTL_VIRTIO_VGPU_TRANSFER_TO_HOST CTL_CODE(FILE_DEVICE_UNKNOWN, \
+    0x809, \
+    METHOD_IN_DIRECT, \
+    FILE_ANY_ACCESS)
+
+#define IOCTL_VIRTIO_VGPU_WAIT CTL_CODE(FILE_DEVICE_UNKNOWN, \
+    0x810, \
+    METHOD_OUT_DIRECT, \
+    FILE_ANY_ACCESS)
+
+#endif
diff --git a/src/gallium/winsys/virgl/lib/meson.build b/src/gallium/winsys/virgl/lib/meson.build
new file mode 100644
index 00000000000..6576e0616ef
--- /dev/null
+++ b/src/gallium/winsys/virgl/lib/meson.build
@@ -0,0 +1,34 @@
+# MVisor vgpu Device guest driver
+# Copyright (C) 2022 cair <rui.cai@tenclass.com>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <https://www.gnu.org/licenses/>.
+
+deps = []
+if host_machine.system() == 'windows'
+  c = meson.get_compiler('c')
+  deps += c.find_library('Setupapi')
+endif
+
+libvgpuapi = static_library(
+  'vgpu_api',
+  'vgpu_api.c',
+  include_directories : [inc_include, inc_src, inc_mapi, inc_mesa, inc_gallium, inc_gallium_aux, inc_gallium_drivers, inc_virtio],
+  dependencies : [dep_libdrm, idep_mesautil, idep_nir_headers, deps],
+  gnu_symbol_visibility : 'hidden',
+)
+
+dep_libvgpuapi = declare_dependency(
+  link_with : libvgpuapi,
+  include_directories : include_directories('.'),
+)
diff --git a/src/gallium/winsys/virgl/lib/vgpu_api.c b/src/gallium/winsys/virgl/lib/vgpu_api.c
new file mode 100644
index 00000000000..ed5a197ccc7
--- /dev/null
+++ b/src/gallium/winsys/virgl/lib/vgpu_api.c
@@ -0,0 +1,300 @@
+/*
+ * MVisor vgpu Device guest driver
+ * Copyright (C) 2022 cair <rui.cai@tenclass.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+
+#include <windows.h>
+#include <stdio.h>
+#include <setupapi.h>
+#include <cfgmgr32.h>
+#include <shlwapi.h>
+
+#include "vgpu_api.h"
+#include "ioctl.h"
+#include "util/u_debug.h"
+
+#include "drm-uapi/virtgpu_drm.h"
+
+
+int drmPrimeHandleToFD(int fd, UINT32 handle, UINT32 flags, int *prime_fd)
+{
+    _debug_printf("drmPrimeHandleToFD not implement\n");
+    return 0;
+}
+
+int drmPrimeFDToHandle(int fd, int prime_fd, UINT32 *handle)
+{
+    _debug_printf("drmPrimeFDToHandle not implement\n");
+    return 0;
+}
+
+drmVersionPtr drmGetVersion(HANDLE fd)
+{
+    drmVersionPtr version = (drmVersionPtr)malloc(sizeof(drmVersion));
+    if (version)
+    {
+        version->version_major = 0;
+        version->version_minor = 0;
+        return version;
+    }
+
+    return NULL;
+}
+
+void drmFreeVersion(drmVersionPtr ptr)
+{
+    if (ptr)
+    {
+        free(ptr);
+    }
+}
+
+HANDLE GetHandleFromVgpu(void)
+{
+    BOOL bRet = FALSE;
+    HANDLE handle = INVALID_HANDLE_VALUE;
+    HDEVINFO HardwareDeviceInfo = NULL;
+    DWORD RequiredLength = 0;
+    PSP_DEVICE_INTERFACE_DETAIL_DATA DeviceInterfaceDetailData = NULL;
+    SP_DEVINFO_DATA DevInfoData = {sizeof(SP_DEVINFO_DATA)};
+    SP_DEVICE_INTERFACE_DATA DeviceInterfaceData;
+    
+    HardwareDeviceInfo = SetupDiGetClassDevs(
+        &GUID_DEVINTERFACE_VGPU,
+        NULL,
+        NULL,
+        (DIGCF_PRESENT | DIGCF_DEVICEINTERFACE)
+        );
+
+    if (HardwareDeviceInfo == INVALID_HANDLE_VALUE)
+    {
+        _debug_printf("Cannot get class devices.\n");
+        return NULL;
+    }
+
+    DeviceInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
+    bRet = SetupDiEnumDeviceInterfaces(HardwareDeviceInfo, NULL, &GUID_DEVINTERFACE_VGPU, 0, &DeviceInterfaceData);
+    if (!bRet)
+    {
+        _debug_printf("SetupDiEnumDeviceInterfaces failed err=%d.\n", GetLastError());
+        return NULL;
+    }
+
+    SetupDiGetDeviceInterfaceDetail(HardwareDeviceInfo, &DeviceInterfaceData, NULL, 0, &RequiredLength, NULL);
+    assert(RequiredLength > 0);
+    
+    DeviceInterfaceDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA)malloc(RequiredLength);
+    if (DeviceInterfaceDetailData == NULL)
+    {
+        _debug_printf("Cannot allocate memory.\n");
+        return NULL;
+    }
+
+    DeviceInterfaceDetailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
+    bRet = SetupDiGetDeviceInterfaceDetail(
+        HardwareDeviceInfo,
+        &DeviceInterfaceData,
+        DeviceInterfaceDetailData,
+        RequiredLength,
+        NULL,
+        &DevInfoData
+        );
+    if (!bRet)
+    {
+        _debug_printf("SetupDiGetDeviceInterfaceDetail failed err=%d.\n", GetLastError());
+        return NULL;
+    }
+
+    handle = CreateFile(DeviceInterfaceDetailData->DevicePath, GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
+    if (handle == INVALID_HANDLE_VALUE)
+    {   
+        _debug_printf("CreateFile failed err=%d.\n", GetLastError());
+        assert(0);
+    }
+
+    free ((PVOID)DeviceInterfaceDetailData);
+    SetupDiDestroyDeviceInfoList(HardwareDeviceInfo);
+    return handle;
+}
+
+static int ctl_get_param(HANDLE handle, struct drm_virtgpu_getparam *getparam)
+{
+    DWORD BytesReturned;
+    BOOL ret = DeviceIoControl(handle, IOCTL_VIRTIO_VGPU_GETPARAM, &getparam->param, sizeof(uint64_t), 
+        (void*)getparam->value, sizeof(uint64_t), &BytesReturned, NULL);
+    if (!ret)
+    {
+        _debug_printf("IOCTL_VIRTIO_VGPU_GETPARAM failed=%d\n", GetLastError());
+        return -1;
+    }
+
+    return 0;
+}
+
+static int ctl_get_caps(HANDLE handle, struct drm_virtgpu_get_caps* getcaps)
+{
+    DWORD BytesReturned;
+    BOOL ret = DeviceIoControl(handle, IOCTL_VIRTIO_VGPU_GET_CAPS, &getcaps->cap_set_id, sizeof(uint32_t) * 2, 
+        (void*)getcaps->addr, getcaps->size, &BytesReturned, NULL);
+    if (!ret)
+    {
+        _debug_printf("IOCTL_VIRTIO_VGPU_GET_CAPS failed=%d\n", GetLastError());
+        return -1;
+    }
+
+    return 0;
+}
+
+static int ctl_create_resource(HANDLE handle, struct drm_virtgpu_resource_create* createcmd)
+{
+    DWORD BytesReturned;
+    BOOL ret = DeviceIoControl(handle, IOCTL_VIRTIO_VGPU_RESOURCE_CREATE, createcmd, sizeof(*createcmd), 
+        (void*)&createcmd->bo_handle, sizeof(uint32_t) * 2, &BytesReturned, NULL);
+    if (!ret)
+    {
+        _debug_printf("IOCTL_VIRTIO_VGPU_RESOURCE_CREATE failed=%d\n", GetLastError());
+        return -1;
+    }
+
+    return 0;
+}
+
+static int ctl_submit_command(HANDLE handle, struct drm_virtgpu_execbuffer* eb)
+{
+    DWORD BytesReturned;
+    BOOL ret = DeviceIoControl(handle, IOCTL_VIRTIO_VGPU_EXECBUFFER, eb, sizeof(*eb), NULL, 0, &BytesReturned, NULL);
+    if (!ret)
+    {
+        _debug_printf("IOCTL_VIRTIO_VGPU_EXECBUFFER failed=%d\n", GetLastError());
+        return -1;
+    }
+
+    return 0;
+}
+
+static int ctl_close_resource(HANDLE handle, struct drm_gem_close* close)
+{
+    DWORD BytesReturned;
+    BOOL ret = DeviceIoControl(handle, IOCTL_VIRTIO_VGPU_RESOURCE_CLOSE, close, sizeof(*close), NULL, 0, &BytesReturned, NULL);
+    if (!ret)
+    {
+        _debug_printf("IOCTL_VIRTIO_VGPU_RESOURCE_CLOSE failed=%d\n", GetLastError());
+        return -1;
+    }
+
+    return 0;
+}
+
+static int ctl_wait_resource(HANDLE handle, struct drm_virtgpu_3d_wait* wait)
+{
+    DWORD BytesReturned;
+    ULONG32 result;
+    BOOL ret = DeviceIoControl(handle, IOCTL_VIRTIO_VGPU_WAIT, wait, sizeof(*wait), &result, sizeof(ULONG32), &BytesReturned, NULL);
+    if (!ret)
+    {
+        _debug_printf("IOCTL_VIRTIO_VGPU_WAIT failed=%d\n", GetLastError());
+        return -1;
+    }
+
+    return result;
+}
+
+static int ctl_map_resource(HANDLE handle, struct drm_virtgpu_map* map)
+{
+    DWORD BytesReturned;
+    BOOL ret = DeviceIoControl(handle, IOCTL_VIRTIO_VGPU_MAP, map, sizeof(*map), &map->offset, sizeof(ULONG64), &BytesReturned, NULL);
+    if (!ret)
+    {
+        _debug_printf("IOCTL_VIRTIO_VGPU_MAP failed=%d\n", GetLastError());
+        return -1;
+    }
+
+    return 0;
+}
+
+static int ctl_transfer_to_host(HANDLE handle, struct drm_virtgpu_3d_transfer* transfer)
+{
+    DWORD BytesReturned;
+    BOOL ret = DeviceIoControl(handle, IOCTL_VIRTIO_VGPU_TRANSFER_TO_HOST, transfer, sizeof(*transfer), NULL, 0, &BytesReturned, NULL);
+    if (!ret)
+    {
+        _debug_printf("IOCTL_VIRTIO_VGPU_TRANSFER_TO_HOST failed=%d\n", GetLastError());
+        return -1;
+    }
+
+    return 0;
+}
+
+static int ctl_transfer_from_host(HANDLE handle, struct drm_virtgpu_3d_transfer* transfer)
+{
+    DWORD BytesReturned;
+    BOOL ret = DeviceIoControl(handle, IOCTL_VIRTIO_VGPU_TRANSFER_FROM_HOST, transfer, sizeof(*transfer), NULL, 0, &BytesReturned, NULL);
+    if (!ret)
+    {
+        _debug_printf("IOCTL_VIRTIO_VGPU_TRANSFER_FROM_HOST failed=%d\n", GetLastError());
+        return -1;
+    }
+
+    return 0;
+}
+
+void DestroyVirglContext(HANDLE handle)
+{
+    bool ret = DeviceIoControl(handle, IOCTL_VIRTIO_VGPU_DESTROY_CONTEXT, NULL, 0, NULL, 0, NULL, NULL);
+    if (!ret)
+    {
+        _debug_printf("IOCTL_VIRTIO_VGPU_DESTROY_CONTEXT failed=%d\n", GetLastError());
+    }
+}
+
+void CreateVirglContext(HANDLE handle)
+{
+    bool ret = DeviceIoControl(handle, IOCTL_VIRTIO_VGPU_CREATE_CONTEXT, NULL, 0, NULL, 0, NULL, NULL);
+    if (!ret)
+    {
+        _debug_printf("IOCTL_VIRTIO_VGPU_CREATE_CONTEXT failed=%d\n", GetLastError());
+    }
+}
+
+int drmIoctl(HANDLE handle, unsigned long request, void *arg)
+{
+    switch (request)
+    {
+    case DRM_IOCTL_VIRTGPU_GETPARAM:
+        return ctl_get_param(handle, arg);
+    case DRM_IOCTL_VIRTGPU_GET_CAPS:
+        return ctl_get_caps(handle, arg);
+    case DRM_IOCTL_VIRTGPU_RESOURCE_CREATE:
+        return ctl_create_resource(handle, arg);
+    case DRM_IOCTL_VIRTGPU_EXECBUFFER:
+        return ctl_submit_command(handle, arg);
+    case DRM_IOCTL_GEM_CLOSE:
+        return ctl_close_resource(handle, arg);
+    case DRM_IOCTL_VIRTGPU_WAIT:
+        return ctl_wait_resource(handle, arg);
+    case DRM_IOCTL_VIRTGPU_MAP:
+        return ctl_map_resource(handle, arg);
+    case DRM_IOCTL_VIRTGPU_TRANSFER_FROM_HOST:
+        return ctl_transfer_from_host(handle, arg);
+    case DRM_IOCTL_VIRTGPU_TRANSFER_TO_HOST:
+        return ctl_transfer_to_host(handle, arg);
+    default:
+        _debug_printf("drmIoctl not implement handle=0x%lx request=0x%x\n", handle, request);
+        return -1;
+    }
+
+    return 0;
+}
diff --git a/src/gallium/winsys/virgl/lib/vgpu_api.h b/src/gallium/winsys/virgl/lib/vgpu_api.h
new file mode 100644
index 00000000000..0e8d7bfdf0d
--- /dev/null
+++ b/src/gallium/winsys/virgl/lib/vgpu_api.h
@@ -0,0 +1,47 @@
+/*
+ * MVisor vgpu Device guest driver
+ * Copyright (C) 2022 cair <rui.cai@tenclass.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+#ifndef VGPU_API_H
+#define VGPU_API_H
+
+/**
+ * Driver version information.
+ *
+ * \sa drmGetVersion() and drmSetVersion().
+ */
+typedef struct _drmVersion {
+    int     version_major;        /**< Major version */
+    int     version_minor;        /**< Minor version */
+    int     version_patchlevel;   /**< Patch level */
+    int     name_len; 	          /**< Length of name buffer */
+    char*   name;	          /**< Name of driver */
+    int     date_len;             /**< Length of date buffer */
+    char*   date;                /**< User-space buffer to hold date */
+    int     desc_len;	          /**< Length of desc buffer */
+    char*   desc;                /**< User-space buffer to hold desc */
+} drmVersion, *drmVersionPtr;
+
+int drmIoctl(HANDLE fd, unsigned long request, void* arg);
+int drmPrimeHandleToFD(int fd, UINT32 handle, UINT32 flags, int* prime_fd);
+int drmPrimeFDToHandle(int fd, int prime_fd, UINT32* handle);
+drmVersionPtr drmGetVersion(HANDLE fd);
+void drmFreeVersion(drmVersionPtr ptr);
+HANDLE GetHandleFromVgpu(void);
+void CreateVirglContext(HANDLE handle);
+void DestroyVirglContext(HANDLE handle);
+
+#endif
diff --git a/src/util/mesa_cache_db.h b/src/util/mesa_cache_db.h
index d88f67ddd4d..e39a07a61f3 100644
--- a/src/util/mesa_cache_db.h
+++ b/src/util/mesa_cache_db.h
@@ -39,6 +39,10 @@ struct mesa_cache_db {
    bool alive;
 };
 
+bool
+mesa_cache_db_entry_remove(struct mesa_cache_db *db,
+                           const uint8_t *cache_key_160bit);
+                           
 #if DETECT_OS_WINDOWS == 0
 bool
 mesa_cache_db_open(struct mesa_cache_db *db, const char *cache_path);
@@ -63,9 +67,6 @@ mesa_cache_db_entry_write(struct mesa_cache_db *db,
                           const uint8_t *cache_key_160bit,
                           const void *blob, size_t blob_size);
 
-bool
-mesa_cache_db_entry_remove(struct mesa_cache_db *db,
-                           const uint8_t *cache_key_160bit);
 
 bool
 mesa_db_wipe_path(const char *cache_path);
-- 
2.29.2.windows.2

